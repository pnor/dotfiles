#+TITLE: Org Mode Configuration
#+AUTHOR: Phillip O'Reggio
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: hideblocks overview
#+BEGIN_SRC emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+END_SRC

* Preamble
Functions used throughout the config

Only run the forms based on which OS

#+begin_src emacs-lisp
(defmacro when-macos (&rest forms)
  "Only run FORMS if OS is MacOS."
  (if IS-MAC
      `(mapc #'eval ',forms)))

(defmacro when-linux (&rest forms)
  "Only run FORMS if OS is Linux."
  (if IS-LINUX
      `(mapc #'eval ',forms)))
#+end_src

Stuff that needs to run early
(fixed!)
#+begin_src emacs-lisp
;; Currently a hack, since the master branch of emacs doesn't load these rn
;; seems to be fixed now
;; (load "~/.emacs.d/modules/config/default/config.el")
;; (load "~/.emacs.d/modules/config/default/+evil-bindings.el")
;; (load "~/.emacs.d/modules/config/default/+evil.el")

;; https://github.com/emacs-mirror/emacs/commit/80cf13a3d27d8a967feafeec32fd130529635592
;; Which changes early expansion from warning to error, since it breaks lsp
(defun internal-macroexpand-for-load (form full-p)
  ;; Called from the eager-macroexpansion in readevalloop.
  (let ((symbols-with-pos-enabled t)
        (print-symbols-bare t))
    (cond
     ;; Don't repeat the same warning for every top-level element.
     ((eq 'skip (car macroexp--pending-eager-loads)) form)
     ;; If we detect a cycle, skip macro-expansion for now, and output a warning
     ;; with a trimmed backtrace.
     ((and load-file-name (member load-file-name macroexp--pending-eager-loads))
      (let* ((bt (delq nil
                       (mapcar #'macroexp--trim-backtrace-frame
                               (macroexp--backtrace))))
             (elem `(load ,(file-name-nondirectory load-file-name)))
             (tail (member elem (cdr (member elem bt)))))
        (if tail (setcdr tail (list 'â€¦)))
        (if (eq (car-safe (car bt)) 'macroexpand-all) (setq bt (cdr bt)))
        (if macroexp--debug-eager
            (debug 'eager-macroexp-cycle)
          (message "Eager macro-expansion skipped due to cycle:\n  %s"
                 (mapconcat #'prin1-to-string (nreverse bt) " => ")))
        (push 'skip macroexp--pending-eager-loads)
        form))
     (t
      (condition-case err
          (let ((macroexp--pending-eager-loads
                 (cons load-file-name macroexp--pending-eager-loads)))
            (if full-p
                (macroexpand--all-toplevel form)
              (macroexpand form)))
        (error
         ;; Hopefully this shouldn't happen thanks to the cycle detection,
         ;; but in case it does happen, let's catch the error and give the
         ;; code a chance to macro-expand later.
         (message "Eager macro-expansion failure: %S" err)
         form))))))
#+end_src

* General
** Private Information
Load some personal information
#+BEGIN_SRC emacs-lisp
(load! "Secret.el")
#+END_SRC

** Library Functions
Functions used in other places in the configs
#+BEGIN_SRC emacs-lisp
;; Get a live xwidget buffer with url opened
(defun personal--xwidget-buffer (url)
  (xwidget-webkit-browse-url url)
  (let ((xwidget-buf (seq-find
                      (lambda (b) (eq (buffer-local-value 'major-mode b) 'xwidget-webkit-mode))
                      (buffer-list))))
    xwidget-buf))
#+END_SRC
** Font, Themes, and the General Look and Behavior
*** Fonts
Keeping all the font information in one place

Setting the main font
#+begin_src emacs-lisp
(if IS-MAC
    (setq doom-font (font-spec :family "CozetteVector" :size 20))
  (setq doom-font (font-spec :family "CozetteVector" :size 28)))
#+end_src

Make some faces use variable pitch
#+begin_src emacs-lisp
(custom-theme-set-faces
   'user
   '(line-number ((t (:inherit fixed-pitch))))
   '(line-numer-current-line ((t (:inherit fixed-pitch))))
   '(doom-modeline-buffer-major-mode ((t (:inherit fixed-pitch)))))
#+end_src

And change the font used for variable pitch fonts in org mode
#+begin_src emacs-lisp
(setq personal-variable-pitch-font (if IS-MAC "Helvetica" "HelveticaNeue-Regular"))
;; (setq personal-variable-pitch-font (if IS-MAC "Helvetica" "Iosevka"))
(setq personal-fixed-pitch-font (if IS-MAC "MesloLGS Nerd Font" "Iosevka"))

(set-face-attribute 'variable-pitch nil :family personal-variable-pitch-font)
(add-hook! org-mode #'variable-pitch-mode)

(after! org-modern
  (set-face-attribute 'org-modern-symbol nil :family personal-fixed-pitch-font)
  (set-face-attribute 'org-block nil :family personal-fixed-pitch-font)
  (set-face-attribute 'org-table nil :family personal-fixed-pitch-font)
  (setq org-modern-table t))
#+end_src


Make fixed pitch not be a constant size, for Demap and such so certain fonts (comments in
particular) don't appear super large compared to everything else
#+begin_src emacs-lisp
(defun personal-make-fixed-pitch-shrink ()
  (interactive)
  (set-face-attribute 'fixed-pitch nil :height 'unspecified))

(personal-make-fixed-pitch-shrink)
(add-hook! org-mode #'personal-make-fixed-pitch-shrink)
(add-hook! prog-mode #'personal-make-fixed-pitch-shrink)
(add-hook! doom-load-theme-hook #'personal-make-fixed-pitch-shrink)

#+end_src

*** Look
Set the color theme and font
#+BEGIN_SRC emacs-lisp
(if IS-MAC
    (setq doom-theme 'starry-transparent)
  (setq doom-theme 'ewal-doom-vibrant))

;; Make comments brighter if using ewal
(setq ewal-doom-vibrant-brighter-comments t)
(setq ewal-doom-vibrant-comment-bg nil)

(when IS-LINUX
  (defun personal-make-ewal-comment-brighter ()
    (interactive)
    (set-face-attribute 'font-lock-comment-face nil :foreground (ewal-load-color 'green -0))))
#+END_SRC

Cursor color
#+begin_src emacs-lisp
(setq evil-normal-state-cursor '(box "#528AF2")
      evil-insert-state-cursor '(bar "#528AF2")
      evil-visual-state-cursor '(hollow "#FDDC87")
      evil-operator-state-cursor '(evil-half-cursor "#528AF2")
      evil-replace-state-cursor '(hbar "#FDDC87"))
#+end_src

Make the emacs frame transparent because I like my laptop background ðŸ™ƒ
#+BEGIN_SRC emacs-lisp
(defun personal-set-alpha-background-frame-params ()
  (let ((bg-transparency 0.7))
    (set-frame-parameter (selected-frame) 'alpha-background bg-transparency)
    (add-to-list 'default-frame-alist `(alpha-background . ,bg-transparency))))

(add-hook 'doom-load-theme-hook #'personal-set-alpha-background-frame-params)
#+END_SRC

And some functions to manipulate transparency on the frame
#+begin_src emacs-lisp
(defun personal-set-alpha-background-on-frame ()
  (interactive)
  (let ((alpha (read-number "Enter transparency (0.0-1.0): ")))
    (set-frame-parameter (selected-frame) 'alpha-background alpha)))
#+end_src

+Make emacs start full screen+
+Emacs starts in a small frame, and goes full screen when reloading session+
Window managers kind of make this problematic
#+begin_src emacs-lisp
;; (if (display-graphic-p)
;;     (defadvice! personal-full-screen-on-reload-last ()
;;       :after #'doom/quickload-session
;;       (toggle-frame-fullscreen)))
(setq initial-frame-alist '((top . 100) (left . 400) (width . 100) (height . 40)))

#+end_src

Show global display fill column
#+BEGIN_SRC emacs-lisp
(global-display-fill-column-indicator-mode t)
#+END_SRC

Show Line numbers
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type t)
#+END_SRC

Modify the appearance of the mode-line
#+BEGIN_SRC elisp
(setq doom-modeline-major-mode-icon t)
#+END_SRC

*** Behavior
Add a fill column to prevent long lines (116 is the width of the vertical monitor)
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 100)
#+END_SRC

and automatically break long lines in source code buffers and org mode files
#+BEGIN_SRC emacs-lisp
(add-hook! prog-mode (auto-fill-mode t))
(add-hook! org-mode (auto-fill-mode t))
#+END_SRC

Show a message when doing garbage collection
#+BEGIN_SRC emacs-lisp
(setq garbage-collection-messages t)
#+END_SRC

Have evil-mode treat emacs /symbols/ as words instead of by character
(symbol definition changes based on the language)
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
    (defalias #'forward-evil-word #'forward-evil-symbol)
    ;; make evil-search-word look for symbol rather than word boundaries
    (setq-default evil-symbol-word-search t))

#+END_SRC

Enable pixel scrolling precision
#+BEGIN_SRC emacs-lisp
(pixel-scroll-precision-mode 1)
(setq pixel-scroll-precision-use-momentum t)
#+END_SRC

#+RESULTS:

** Splash Screen Edits
Function for making random wave art for the banner
#+begin_src emacs-lisp :lexical t

(setq personal-wave-param-low 1)
(setq personal-wave-param-high 100)

(defun personal-wave-function-1 (x y a b c d)
  (let* ((highest-magnitude (+ 1 1))
         (wave-result (+ (sin (* (/ a b) x)) (sin (* (/ c d 1.0) y))))
         (normalized (/ (+ wave-result highest-magnitude) (* 2 highest-magnitude))))
    normalized))

(defun personal-wave-function-2 (x y a b c d)
  (let* ((highest-magnitude 1)
         (wave-result (sin (* x y (/ a c 1.0) (/ b d 1.0))))
         (normalized (/ (+ wave-result highest-magnitude) (* 2 highest-magnitude))))
    normalized))

(defun personal-intensity-to-character (intensity)
  "Maps INTENSITY to a character from .,-~:;=!*#$@"
  (pcase intensity
    ((pred (lambda (x) (<= x (* 1 0.077))))
     ?\s)
    ((pred (lambda (x) (<= x (* 2 0.077))))
     ?\s)
    ((pred (lambda (x) (<= x (* 3 0.077))))
     ?\s)
    ((pred (lambda (x) (<= x (* 4 0.077))))
     ?.)
    ((pred (lambda (x) (<= x (* 5 0.077))))
     ?-)
    ((pred (lambda (x) (<= x (* 6 0.077))))
     ?:)
    ((pred (lambda (x) (<= x (* 7 0.077))))
     ?\;)
    ((pred (lambda (x) (<= x (* 8 0.077))))
     ?=)
    ((pred (lambda (x) (<= x (* 9 0.077))))
     ?!)
    ((pred (lambda (x) (<= x (* 10 0.077))))
     ?*)
    ((pred (lambda (x) (<= x (* 11 0.077))))
     ?#)
    ((pred (lambda (x) (<= x (* 12 0.077))))
     ?$)
    ((pred (lambda (x) (<= x (* 13 0.077))))
     ?@)
    (x
     ?\@)))

(defun personal-scale-to-2pi (cur max)
  "Scales a number CUR between [0, max) to [0, 2pi)"
  (* (/ cur max 1.0) (* float-pi 2)))

(defun personal-make-ascii-wave-art (height width)
  (let ((output-lines (mapcar (lambda (c) (make-string width c)) (make-list height ?.)))
        (wave-func (if (= 1 (random 5)) #'personal-wave-function-2 #'personal-wave-function-1))
        (a (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low))
        (b (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low))
        (c (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low))
        (d (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low)))
    (cl-loop for i from 0 to (- height 1) do
             (cl-loop for j from 0 to (- width 1) do
                      (let* ((x (personal-scale-to-2pi j width))
                             (y (personal-scale-to-2pi i height))
                             (intensity (apply wave-func `(,x ,y ,a ,b ,c ,d)))
                             (character (personal-intensity-to-character intensity)))
                        (aset (nth i output-lines) j character))))

    output-lines))

(after! +doom-dashboard-mode-hook
  (personal-make-ewal-comment-brighter))
#+end_src

Custom Banner text
#+begin_src emacs-lisp :lexical t
(setq personal-wave-width 60)
(setq personal-wave-height 30)

(defun personal-custom-splash-ascii ()
  (let* ((banner
          (personal-make-ascii-wave-art personal-wave-height personal-wave-width))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(setq +doom-dashboard-ascii-banner-fn #'personal-custom-splash-ascii)
#+end_src

Remove splash screen menu options I don't use
#+begin_src emacs-lisp
(defun personal-change-doom-dashboard-options ()
  "Change dashboard options for start screen"
  (require 'all-the-icons)
  (after! all-the-icons
    (setq +doom-dashboard-menu-sections
          '(("Resume" :icon
             (all-the-icons-octicon "history" :face 'doom-dashboard-menu-title)
             :when
             (cond
              ((featurep! :ui workspaces)
               (file-exists-p
                (expand-file-name persp-auto-save-fname persp-save-dir)))
              ((require 'desktop nil t)
               (file-exists-p
                (desktop-full-file-name))))
             :face
             (:inherit
              (doom-dashboard-menu-title bold))
             :action doom/quickload-session)
            ("Config" :icon
             (all-the-icons-octicon "tools" :face 'doom-dashboard-menu-title)
             :when
             (file-directory-p doom-private-dir)
             :action doom/open-private-config)))
    )
  )

(personal-change-doom-dashboard-options)
#+end_src

Last Crash Info (for MacOS)
(unused now since I don't use Emacs on MacOS much
#+begin_src emacs-lisp
;; (defun personal--last-crash-delta (crash-log-dir emacs-crash-cache-file)
;;   "Computes time since last crash.
;; Return result as a numeric number that needs to be converted to human readable string using `ts-human-format-duration'.
;; 
;; CRASH-LOG-DIR is the directory where Emacs crash log is located (used to run touch).
;; 
;; EMACS-CRASH-CACHE-file is a file (may not exist yet) that stores the time of the latest crash. Is
;; used when the CRASH-LOG-DIR has no information for the last crash time, and is created/updated on
;; each parse."
;;   (require 'ts)
;;   (let* ((dir-name (expand-file-name crash-log-dir))
;;          (last-crash-log (shell-command-to-string (format "ls -r %s | rg -i emacs | head -1"
;;                                                           dir-name))))
;;     (if (length= last-crash-log 0)
;;         (personal--use-crash-cache (expand-file-name emacs-crash-cache-file))
;;       (personal--use-crash-log
;;        (expand-file-name crash-log-dir)
;;        (expand-file-name emacs-crash-cache-file)))))
;; 
;; (defun personal--use-crash-cache (emacs-crash-cache-file)
;;   (unless (file-exists-p emacs-crash-cache-file)
;;     (write-region (shell-command-to-string "date -R") nil emacs-crash-cache-file))
;;   (let ((last-crash-string (with-temp-buffer
;;                         (insert-file-contents emacs-crash-cache-file)
;;                         (buffer-string))))
;;     (personal--compute-delta last-crash-string)))
;; 
;; (defun personal--use-crash-log (log-file cache-file)
;;   (let ((last-crash-string
;;          (shell-command-to-string (format "date -r %s -R" log-file))))
;;     (write-region last-crash-string nil cache-file)
;;     (personal--compute-delta last-crash-string)))
;; 
;; (defun personal--compute-delta (last-crash-time-string)
;;   (ts-diff (ts-parse (shell-command-to-string "date -R")) (ts-parse last-crash-time-string)))
;; 
;; (defun personal--is-longest-no-crash-time (delta best-time-file)
;;   "Return `t' if DELTA is bigger than the number in BEST-TIME-FILE.
;; Also handles updating the number if it is bigger, or creating it if it doesn't exist."
;;   (let ((best-time-file-name (expand-file-name best-time-file)))
;;     (unless (file-exists-p best-time-file-name)
;;       (write-region "0" nil best-time-file-name))
;;     (let ((best-delta (string-to-number (with-temp-buffer
;;                         (insert-file-contents best-time-file-name)
;;                         (buffer-string)))))
;;       (if (> delta best-delta)
;;           (progn
;;             ;; write that to file instead
;;             (write-region (number-to-string delta) nil best-time-file-name)
;;             ;; return t
;;             t)
;;         nil))))
;; 
;; 
;; (defun doom-last-crash-line ()
;;   "Say how long since Emacs last crashed.
;; BEST-TIME-NAME is optional and specifies absolute path to file that contains the longest time Emacs"
;;   (let* ((delta (personal--last-crash-delta "~/Library/Logs/DiagnosticReports" "~/.doom.d/splash-last-crash.txt"))
;;          (delta-string (ts-human-format-duration delta)))
;;     (if (personal--is-longest-no-crash-time delta "~/.doom.d/splash-longest-last-crash.txt")
;;         (format "%s since last incident! (NEW RECORD!)" delta-string)
;;       (format "%s since last incident!" delta-string))))
;; 
;; (defun doom-dashboard-phrase ()
;;   "Get a splash phrase, flow it over multiple lines as needed, and make fontify it."
;;   (mapconcat
;;    (lambda (line)
;;      (+doom-dashboard--center
;;       +doom-dashboard--width
;;       (with-temp-buffer
;;         (insert-text-button
;;          line
;;          'action
;;          (lambda (_) (+doom-dashboard-reload t))
;;          'face 'doom-dashboard-menu-title
;;          'mouse-face 'doom-dashboard-menu-title
;;          'help-echo "Last crash"
;;          'follow-link t)
;;         (buffer-string))))
;;    (split-string
;;     (with-temp-buffer
;;       (insert (doom-last-crash-line))
;;       (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
;;       (fill-region (point-min) (point-max))
;;       (buffer-string))
;;     "\n")
;;    "\n"))
;; 
;; ;; Only place this message if ts is available (avoid startup errors)
;; (when (require 'ts nil 'noerror)
;;   (defadvice! doom-dashboard-widget-loaded-with-phrase ()
;;     :override #'doom-dashboard-widget-loaded
;;     (setq line-spacing 0.2)
;;     (insert
;;      "\n\n"
;;      (propertize
;;       (+doom-dashboard--center
;;        +doom-dashboard--width
;;        (doom-display-benchmark-h 'return))
;;       'face 'doom-dashboard-loaded)
;;      "\n"
;;      (doom-dashboard-phrase)
;;      "\n")))
;; 
;; (if IS-MAC
;;     (add-hook 'doom-load-theme-hook #'personal-change-doom-dashboard-options))
#+end_src

** Useful Functions
*** New Functions
Toggle the transparency of emacs
#+BEGIN_SRC emacs-lisp
;; Initialize transparency to `true`

;; TODO change this to not use global state, but instead use frame-local state

(put 'cfg-transparency 'state t)

(defun personal-toggle-transparency ()
  "Toggle the transparency of emacs"
  (interactive)
  (if (get 'cfg-transparency 'state)
      (progn
        (set-frame-parameter (selected-frame) 'alpha '(100 100))
        (put 'cfg-transparency 'state nil))
    (progn
      (set-frame-parameter (selected-frame) 'alpha '(85 85))
      (put 'cfg-transparency 'state t))
    ))
#+END_SRC

Control size of Emacs frame:
#+BEGIN_SRC emacs-lisp
(defun personal-frame-change-size (width height)
  "Modify size of window frame by increasing it by WIDTH and HEIGHT."
  (let ((cur-width (frame-width (window-frame)))
        (cur-height (frame-height (window-frame))))
    (set-frame-size (window-frame) (+ cur-width width) (+ cur-height height))))

(defun personal-frame-full-screen ()
  "Toggle frame to be fullscreen."
  (interactive)
  (toggle-frame-fullscreen))

(defun personal-frame-increase-width ()
  "Increase frame width by 1."
  (interactive)
  (personal-frame-change-size 1 0))

(defun personal-frame-decrease-width ()
    "Decrease frame width  by 1."
    (interactive)
    (personal-frame-change-size -1 0))

(defun personal-frame-increase-height ()
    "Increase frame height by 1."
    (interactive)
    (personal-frame-change-size 0 1))

(defun personal-frame-decrease-height ()
    "Decrease frame height by 1."
    (interactive)
    (personal-frame-change-size 0 -1))

(defun personal-frame-increase-diag ()
    "Increase frame width and height by 1."
    (interactive)
    (personal-frame-change-size 1 1))

(defun personal-frame-decrease-diag ()
    "Decrease frame width and height by 1."
    (interactive)
    (personal-frame-change-size -1 -1))
#+END_SRC

Control position of emacs frame:
#+BEGIN_SRC emacs-lisp
(defun personal-frame-move (down right)
  "Move window frame by DOWN and RIGHT."
  (pcase (frame-position)
    (`(,x . ,y) (set-frame-position (selected-frame) (+ x right) (+ y down)))))

(defun personal-move-frame-down-30 ()
  "Move window frame down 30."
  (interactive)
  (personal-frame-move 30 0))

(defun personal-move-frame-down-5 ()
  "Move window frame down 5."
  (interactive)
  (personal-frame-move 5 0))

(defun personal-move-frame-up-30 ()
  "Move window frame up 30."
  (interactive)
  (personal-frame-move -30 0))

(defun personal-move-frame-up-5 ()
  "Move window frame down 5."
  (interactive)
  (personal-frame-move -5 0))

(defun personal-move-frame-left-30 ()
  "Move window frame left 30."
  (interactive)
  (personal-frame-move 0 -30))

(defun personal-move-frame-left-5 ()
  "Move window frame left 5."
  (interactive)
  (personal-frame-move 0 -5))

(defun personal-move-frame-right-30 ()
  "Move window frame right 30."
  (interactive)
  (personal-frame-move 0 30))

(defun personal-move-frame-right-5 ()
  "Move window frame right 5."
  (interactive)
  (personal-frame-move 0 5))
#+END_SRC

Change fill-column
#+BEGIN_SRC elisp
#+END_SRC

Open up terminal in narrow vertical split
#+BEGIN_SRC emacs-lisp
(defun personal-sterm ()
  "Opens a terminal in a split on the left"
  (interactive)
  (require 'vterm)
  (progn
    (split-window-right 45)
    (+vterm/here t)))
#+END_SRC

Open up google in a split
#+BEGIN_SRC elisp
(defun personal-google-split ()
  "Open google in vertical split using xwidget-webkit"
  (interactive)
  (let ((google-url "https://www.google.com")
        (xwidget-buffer (lambda ()
                          (seq-find
                           (lambda (b) (eq (buffer-local-value 'major-mode b) 'xwidget-webkit-mode))
                           (buffer-list)))))
    (split-window-right)
    (xwidget-webkit-browse-url google-url)
    (switch-to-buffer (funcall xwidget-buffer))))

(defun personal-google-here ()
  "Open google in current buffer"
  (interactive)
  (let ((google-url "https://www.google.com"))
    (personal--xwidget-buffer google-url)))
#+END_SRC

Open google in window with xwidget
#+BEGIN_SRC elisp
(defun personal-open-google ()
  "Open google in in window using xwidget-webkit"
  (interactive)
  (let ((google-url "https://www.google.com"))
    (xwidget-webkit-browse-url google-url)))
#+END_SRC

*** Changing Old Ones
nothing yet

** Keybindings and Custom Commands
*** Keybindings
Make moving around splits as easy as pressing space.
#+BEGIN_SRC emacs-lisp
(map! :leader :mode 'global
  "h" #'evil-window-left
  "l" #'evil-window-right
  "j" #'evil-window-down
  "k" #'evil-window-up

  "H" #'+evil/window-move-left
  "L" #'+evil/window-move-right
  "K" #'+evil/window-move-up
  "J" #'+evil/window-move-down
  )
#+END_SRC

Change =;= to =:= (for vim ex mode)
#+BEGIN_SRC emacs-lisp
(map! :nv
  ";" 'evil-ex
  )
#+END_SRC

Map "s" to the sneak motion
#+BEGIN_SRC emacs-lisp
;; Unbind "s" from everything else
(map!
 :map evil-normal-state-map
 "s" nil
 "S" nil)

;; Then bind it
(map!
 :nv "s" #'evil-avy-goto-char-2-below
 :n "S" #'evil-avy-goto-char-2-above)
#+END_SRC

*** Custom ex Commands
~:G~ for magit status
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "G" #'magit-status)
#+END_SRC

~:S~ to search google and ~:SS~ to open google in current frame
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "S" #'personal-google-split)
(evil-ex-define-cmd "SS" #'personal-google-here)
#+END_SRC

~:E~ to search google with eww
#+BEGIN_SRC emacs-lisp
(defun personal-eww-google ()
  (interactive)
  (let* ((query (read-from-minibuffer "Search for: "))
         (url-extension (replace-regexp-in-string " " "+" query )))
  (eww (concat "https://www.google.com/search?q=" url-extension))))

(evil-ex-define-cmd "E" #'personal-eww-google)
#+END_SRC

~:Fexplore~ to open a project drawer
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "Fexplore" #'treemacs)
#+END_SRC

~:PRReview~ to diff between two branches
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "PRReview" #'magit-diff-range)
#+END_SRC

~:STerm~ to open terminal in a split
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "STerm" #'personal-sterm)
#+END_SRC

** Memory Usage
Let Emacs use more memory for reading and garbage collection
#+begin_src elisp
;; 100 mb
(setq gc-cons-threshold 100000000)
(setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src

** Fixing Things
A place for hacks and functions to fix fires

(nothing right now)

** Abbrevs
Manage abbreviations
#+BEGIN_SRC emacs-lisp
(quietly-read-abbrev-file (expand-file-name "~/.doom.d/abbrev.el"))
#+END_SRC

* Modes
** Text Mode
Mode for human readable text

Recommend words when typing in text mode files:
#+BEGIN_SRC emacs-lisp
(add-hook! text-mode
  (set-company-backend! 'text-mode 'company-dabbrev 'company-ispell)
)
#+END_SRC

** Org Mode
*** Look
Use org modern mode
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook #'org-modern-mode)
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)
#+END_SRC

Set the org directory for org related files
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/agenda")
#+END_SRC

Make org-mode documents look a little nicer by hiding markers and showing symbols
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
(setq org-pretty-entities t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (setq
;;     org-superstar-headline-bullets-list '("â–" "â—‰" "â—‹" "âœ¸" "âœ¿")
;; )
#+END_SRC

_Snippets to prettify Org mode based on this:_ [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][Beautifying Org Mode in Emacs]]:

Make org-mode files use variable pitch fonts to look more like text documents
([[*Fonts][See this]])

Files can opt out by having this at the *end* of the file:
#+BEGIN_EXAMPLE org
;; Local Variables:
;; eval: (variable-pitch-mode 0)
;; End:
#+END_EXAMPLE

*** Functionality
Set up completion for org mode files
Recommend words when typing in text mode files:
#+begin_src emacs-lisp
;; (add-hook! org-mode
;;   (set-company-backend! 'org-mode 'company-dabbrev 'company-ispell))
#+end_src

Add =proselint= to lint org-mode
#+begin_src elisp
(setq flycheck-proselint-executable "~/Library/Python/3.8/bin/proselint")
#+end_src

Setup =org-download=, which makes the process of putting images into orgmode much easier
Put downloaded images into an =images= directory and include timestamp. Use the command =pngpaste= to get the image
from the clipboard.
#+begin_src emacs-lisp
(after! org-download
  (setq org-download-method 'directory)
  (setq-default org-download-image-dir "images")
  (setq org-download-timestamp "%Y%m%d-%H%M%S_")
  (setq org-download-screenshot-method "/usr/local/bin/pngpaste %s"))
#+end_src

Advice =org-fancy-priorities-mode= which sometimes errors since =org-download= hasn't loaded yet
#+begin_src emacs-lisp
(defadvice! personal--load-org-download-with-fancy-priorities ()
  :before #'org-fancy-priorities-mode
  (require 'org-download))
#+end_src

Allow pasting of images with control over the width, and bind it to keybind
#+begin_src emacs-lisp
(defun org-download-screenshot-with-size ()
  "Prompt user for a width to paste the image. Only lasts for this one function"
  (interactive)
  (let ((width (read-number "Enter width: ")) (prev-width org-download-image-html-width))
    (progn
      (setq org-download-image-html-width width)
      (org-download-screenshot)
      (setq org-download-image-html-width prev-width))))

(map! :mode 'org-mode :leader
      "v" #'org-download-screenshot-with-size)
#+end_src

Make drag-and-drop of images work with dired (untested)
#+BEGIN_SRC emacs-lisp
;; Drag-and-drop to `dired`
(add-hook 'dired-mode-hook 'org-download-enable)
#+END_SRC

Make latex previews nice and big
#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 3.0)))
#+END_SRC

** Org Journal
Encrypt the journal (?)
#+BEGIN_SRC elisp
;; ...
#+END_SRC

Set the dir
#+BEGIN_SRC elisp
(setq org-journal-dir "~/Dropbox/agenda/journal")
#+END_SRC

** Ivy
Config for the search engine, Ivy.

Allow fuzzy searches to make it easier to find matches with less thought.
#+BEGIN_SRC emacs-lisp
(setq ivy-re-builders-alist
      '((t . ivy--regex-fuzzy)))
#+END_SRC

Interactive functions to make toggling fuzzy search and strict search easier
#+BEGIN_SRC emacs-lisp
(defun personal-set-fuzzy-ivy ()
  "Make ivy use fuzzy searching"
  (interactive)
  (setq ivy-re-builders-alist
        '((t . ivy--regex-fuzzy))))

(defun personal-set-strict-ivy ()
  "Make ivy use more strict searching"
  (interactive)
  (setq ivy-re-builders-alist
        '((t . ivy--regex))))
#+END_SRC

** Working with PDFs
Make PDFs look sharper on MacOS
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq pdf-view-use-scaling t pdf-view-use-imagemagick nil))
#+END_SRC

** Company
Configure completion settings;
Make it faster for code buffers, but slow for org-mode when writing prose
#+BEGIN_SRC emacs-lisp
(defun personal-set-company-for-prose ()
  "Change company configs for writing prose"
  (interactive)
  (setq
   company-idle-delay 0.3
   company-minimum-prefix-length 4))

(defun personal-set-company-for-code ()
  "Change company configs for writing code"
  (interactive)
  (setq
   company-idle-delay 0.1
   company-minimum-prefix-length 2))
#+END_SRC

** Company Box
Make the company-box frame not transparent
#+BEGIN_SRC emacs-lisp
(after! company-box
  (push '(alpha-background . 1.0) company-box-frame-parameters))
#+END_SRC

** Flycheck
Set python path
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq flycheck-json-python-json-executable "/usr/local/bin/python3"))
#+END_SRC

handle next checkers after =lsp=
#+begin_src emacs-lisp
(defvar-local personal-flycheck-local-cache nil)

(defun personal-flycheck-checker-get (fn checker property)
  (or (alist-get property (alist-get checker personal-flycheck-local-cache))
      (funcall fn checker property)))

(advice-add 'flycheck-checker-get :around 'personal-flycheck-checker-get)

(add-hook 'lsp-managed-mode-hook
          (lambda ()
            (when (derived-mode-p 'sh-mode)
              (setq personal-flycheck-local-cache '((lsp . ((next-checkers . (sh-posix-bash)))))))
            (when (derived-mode-p 'c++-mode)
              (setq personal-flycheck-local-cache '((lsp . ((next-checkers . (c/c++-cppcheck)))))))))

#+end_src

** Evil-snipe mode
Disable =evil-snipe= mode to use =evil-avy-goto-char-2-below=
#+BEGIN_SRC emacs-lisp
(remove-hook 'doom-first-input-hook #'evil-snipe-mode)
#+END_SRC

** Evil quickscope
Always turn on quick scope in programming modes
#+BEGIN_SRC elisp
(add-hook 'prog-mode-hook 'turn-on-evil-quickscope-always-mode)
#+END_SRC

Disable font for second matches, and make the letter be bold for first matches
#+BEGIN_SRC elisp
(custom-theme-set-faces
   'user
   '(evil-quickscope-first-face ((t (:inherit unspecified :weight semibold))))
   '(evil-quickscope-second-face ((t (:inherit unspecified :weight unspecified)))))
#+END_SRC

** Floatbuf
Set floatbuf frame parameters
#+begin_src emacs-lisp
(after! floatbuf
  (push '(alpha . 100) floatbuf-frame-params)
  (push '(alpha-background . 0.65) floatbuf-frame-params)
  (if (not IS-MAC)
      (push '(parent-frame . nil) floatbuf-frame-params)))
#+end_src

#+RESULTS:
: ((parent-frame) (alpha-background . 0.65) (alpha . 100) (parent-frame) (alpha-background . 0.65) (alpha . 100) (vertical-scroll-bars) (tool-bar-lines . 0) (menu-bar-lines . 0) (buffer-predicate . doom-buffer-frame-predicate))

    Add key mappings for floating buffers
#+BEGIN_SRC emacs-lisp
(require 'floatbuf)

(after! floatbuf
  ;; with buffer
  (defun personal-floatbuf-with-buffer ()
    "Create floating buffer with the current buffer."
    (interactive)
    (floatbuf-make-floatbuf))
  ;; with terminal
  (defun personal-floatbuf-with-terminal ()
    "Create floating buffer with the a terminal."
    (interactive)
    (floatbuf-make-floatbuf)
    (+vterm/here nil))
  ;; scratch buffer
  (defun personal-floatbuf-with-scratch ()
    "Create floating buffer with the a scratch buffer"
    (interactive)
    (floatbuf-make-floatbuf-with-buffer (get-buffer "*scratch*")))
  ;; Epaint
  (defun personal-floatbuf-with-epaint ()
    "Create floating buffer with an epaint buffer"
    (interactive)
    (floatbuf-make-floatbuf)
    (epaint))
  ;; web browser
  (defun personal-floatbuf-with-xwidget ()
    "Create floating buffer with the xwidget"
    (interactive)
    (floatbuf-make-floatbuf)
    (personal-google-here))
  ;; mapping
  (map! :leader :mode 'global
        "fbS" #'personal-floatbuf-with-xwidget
        "fbe" #'personal-floatbuf-with-epaint
        "fbf" #'floatbuf-make-floatbuf
        "fbs" #'personal-floatbuf-with-scratch
        "fbt" #'personal-floatbuf-with-terminal))
#+END_SRC

** Lsp mode
Make =lsp-ui= frame not transparent
#+BEGIN_SRC elisp
(after! lsp-ui
  (push '(alpha . 100) lsp-ui-doc-frame-parameters))
#+END_SRC

Disable =lsp-ui-doc=
#+begin_src emacs-lisp
(after! lsp-ui
  (setq lsp-ui-doc-enable nil))
#+end_src

** Centaur Tabs
Turn off tabs when the frame has a lot of splits in it (change function =personal-tab-window-limit=)
#+begin_src emacs-lisp
(defun personal-manage-tabs-with-splits (num-splits)
  "Hide tab bar when NUM-SPLITS or more (>=) windows are in the frame."
  (if (length> (window-list) (- num-splits 1))
      (walk-windows (lambda (w) (with-selected-window w (centaur-tabs-local-mode 1))))
    (walk-windows (lambda (w) (with-selected-window w (centaur-tabs-local-mode -1))))))

(defun personal-tab-window-limit ()
  "Function that is used in hook that calls `personal-manage-tabs-with-splits' with arg."
  (unless (frame-parent) ;; don't mess with tabs if its a child frame
    (personal-manage-tabs-with-splits 3)))

(if (and (display-graphic-p) (not (daemonp)))
    (after! centaur-tabs
      (add-hook! 'window-configuration-change-hook #'personal-tab-window-limit)))

;; Dont show tabs if in terminal mode (doesn't look good)
(unless (display-graphic-p)
  (centaur-tabs-mode -1))

;; Don't use centaur tabs if started as a daemon
(after! centaur-tabs
  (when (daemonp)
    (centaur-tabs-mode -1)))
#+end_src

** Elfeed
Set the org file that configures feed
#+begin_src emacs-lisp
(setq rmh-elfeed-org-files '("~/.doom.d/elfeed.org"))
#+end_src

** vterm
Bind key to =vterm-other-window= which happens to open a terminal to the directory of the file it was
invoked in (useful)
#+begin_src emacs-lisp
(defun personal-vterm-here ()
  (interactive)
  "Open vterm in the directory of cursor.
Just calls `vterm-other-window', but also requires it to make it load beforehand."
  (require 'vterm)
  (vterm-other-window))

(map! :leader :mode 'global
      "oh" #'personal-vterm-here)
#+end_src
** vlc
From [[https://ag91.github.io/blog/2021/01/25/vlc-via-emacs-how-to-open-a-youtube-link/][this page]]; setting up VLC so I can browse music in Emacs
#+begin_src emacs-lisp
(after! vlc
  (defun vlc-add-uri (uri &optional noaudio novideo)
    "Add URI to playlist and start playback.
NOAUDIO and NOVIDEO are optional options.
If NOAUDIO is non-nil, disable audio.
If NOVIDEO is non-nil, disable video.
When called interactively, with prefix arg, you can pick one."
    (interactive (cons (let ((uri (read-string "Add file or url: ")))
                         (if (s-starts-with-p "http" uri) uri
                           (concat "file://" (expand-file-name uri))))
                       (pcase current-prefix-arg
                         ('nil (list nil nil))
                         (_ (pcase (completing-read "Option: " '("noaudio" "novideo") nil t)
                              ("noaudio" (list t nil))
                              ("novideo" (list nil t)))))))
    (vlc-add uri noaudio novideo))

  (defun vlc-enqueue-uri (uri)
    "Add URI to playlist."
    (interactive (list (let ((uri (read-string "Add file or url: ")))
                         (if (s-starts-with-p "http" uri) uri
                           (concat "file://" (expand-file-name uri))))
                       ))
    (vlc-enqueue uri)))
#+end_src

Suggested from above link: add videos to queue if cursor is on it, and link in kill ring
#+begin_src emacs-lisp
(defun vlc-enqueue-uri-at-point ()
    "Add URI to playlist."
    (interactive)
    (let ((uri (thing-at-point 'url)))
      (when uri (vlc-enqueue uri))))

(defun vlc-uris-in-clipboard ()
    (--> (with-temp-buffer
           (clipboard-yank)
           (buffer-substring-no-properties (point-min) (point-max)))
         (s-split "\n" it)
         (--filter (s-starts-with-p "http" it) it)))

(defun vlc-enqueue-uris (uris)
    "Queue URIS to current VLC playlist."
    (interactive)
    (let ((uris (or uris (vlc-uris-in-clipboard))))
      (-each uris 'vlc-enqueue-uri)))

#+end_src

Keybinds for music playing (Use =<leader>1v= as the global keybind)
#+begin_src emacs-lisp
(map! :leader :mode 'global
      "1vs" #'vlc-start
      "1vr" #'vlc-play
      "1vR" #'vlc-pause
      "1vn" #'vlc-next
      "1vp" #'vlc-prev
      "1va" #'vlc-enqueue-uri-at-point
      "1ve" #'vlc-empty)
#+end_src

Function for opening up list
#+begin_src emacs-lisp
(defun personal-vlc-music-list ()
  (interactive)
  (let ((buf (find-file-noselect "~/Dropbox/agenda/music.org")))
    (floatbuf-make-floatbuf-with-buffer buf)))

(map! :leader :mode 'global
      "fbv" #'personal-vlc-music-list)
#+end_src

Strip music org file of song urls
#+begin_src emacs-lisp
(defun personal-queue-all-into-vlc ()
  "Use awk to put all files into vlc queue"
  (interactive)
  (require 'vlc)
  (let*
      ((music-file-loc (expand-file-name "~/Dropbox/agenda/music.org"))
       (awk-script-loc (expand-file-name "~/.doom.d/music-list-parse-all.awk"))
       (urls
        (shell-command-to-string (format "%s %s" awk-script-loc music-file-loc))))
    (mapc #'vlc-add-uri (split-string urls))))
#+end_src

** Tree Sitter
#+begin_src emacs-lisp
(add-hook 'c-mode-common-hook #'tree-sitter-hl-mode)
#+end_src

** Blamer
Enable Blamer
#+begin_src emacs-lisp
(after! blamer
  (global-blamer-mode 1))

;; Make blamer load
(after! magit
       (require 'blamer))
#+end_src

** Demap
List of buffers and modes to not show the minimap in
#+begin_src emacs-lisp
(defvar personal-minimap-exclude-buffer-names '("*doom*")
  "List of buffer names that should not show the minibuffer if any are on the current frame")
(defvar personal-minimap-exclude-modes '(pdf-view-mode vterm-mode dired-mode image-mode magit-mode tetris-mode)
  "List of modes that should not show the minibuffer if any are on the current frame")
#+end_src

#+RESULTS:
: personal-minimap-exclude-modes

A function to start and stop the demap hook
#+begin_src emacs-lisp
(defun personal-start-demap-hook ()
  "Start the hook that shows a minimap if there's only 1 buffer"
  (interactive)
  (require 'demap)
  (require 'dash)
  (add-hook! 'window-configuration-change-hook #'personal-minimap-for-one-window)
  (setq personal-demap-hook-active t))

(defun personal-stop-demap-hook ()
  "Stop the hook that shows a minimap if there's only 1 buffer"
  (interactive)
  (remove-hook! 'window-configuration-change-hook #'personal-minimap-for-one-window)
  (setq personal-demap-hook-active nil))

(defun personal-toggle-demap-hook ()
  "Toggle the hook that shows a minimap if there's only 1 buffer"
  (interactive)
  (if personal-demap-hook-active
      (personal-stop-demap-hook)
    (personal-start-demap-hook)))
#+end_src

Turn on the minimap when there is only 1 active window
#+begin_src emacs-lisp
(defun personal-should-show-minimap ()
  "`nil' if the window doesn't contain something that shouldn't have a minimap."
  (cl-flet ((has-excluded-name (w)
         ;; don't show if it has an excluded name
         (member (buffer-name (window-buffer w)) personal-minimap-exclude-buffer-names))
        (has-excluded-mode (w)
         ;; don't show if one of these modes is included
         (member (with-current-buffer (window-buffer w) major-mode) personal-minimap-exclude-modes)))
    (and
     (display-graphic-p)
     (not (-any? (lambda (w) (or (has-excluded-name w) (has-excluded-mode w))) (window-list nil 1 nil))))))

(defun personal-manage-minimap-with-splits (num-splits)
  "hide/show demap minimap when num-splits or more (>=) windows are in the frame."
  (let ((window-list-without-minimap
         (-filter
          (lambda (n) (not (string= n demap-minimap-default-name)))
          (mapcar (lambda (w) (buffer-name (window-buffer w))) (window-list nil 1 nil)))))
    (if (and (personal-should-show-minimap) (not (length> window-list-without-minimap (- num-splits 1))))
        (progn (demap-open))
      (progn (demap-close)))))

(defun personal-minimap-for-one-window ()
  "function that is used in hook that calls `personal-manage-minimap-with-splits'."
  (unless (frame-parent) ;; don't mess with minimap in child frames
    (personal-manage-minimap-with-splits 2)))
#+end_src

Keybinding for toggling demap minimap
#+begin_src emacs-lisp
(map! :after demap :leader :mode 'global
  "tm" #'demap-toggle
  "tM" #'personal-toggle-demap-hook)
#+end_src

Autostart the hook
#+begin_src emacs-lisp
(personal-start-demap-hook)
#+end_src
** Leetcode
Randomize the language I solve questions in
#+begin_src emacs-lisp
;; (after! leetcode
;;   (setq personal-leetcode-random-languages
;;         '("c"
;;           "c++"
;;           "java"
;;           "rust"
;;           "python3"
;;           "c#"
;;           "typescript"
;;           "swift"
;;           "go"
;;           "scala"
;;           "elixir"
;;           "scala"))
;;
;;   (defun personal-choose-random-leetcode-language ()
;;     (interactive)
;;     (let ((language (nth (random (length personal-leetcode-random-languages)) personal-leetcode-random-languages)))
;;       (setq leetcode-prefer-language language)))
;;
;;   (defun personal-set-leetcode-language ()
;;     (interactive)
;;     (setq leetcode-prefer-language (read-from-minibuffer "language? ")))
;;
;;   (defadvice! personal-leetcode-randomize-language ()
;;     :after #'leetcode
;;     (personal-choose-random-leetcode-language)))

;;(after! leetcode
;;  (defun personal-choose-random-leetcode-language ()
;;    (interactive)
;;    (let ((language (nth (random (length personal-leetcode-random-languages)) personal-leetcode-random-languages)))
;;      (setq leetcode-prefer-language "cpp")))
;;
;;  (defun personal-set-leetcode-language ()
;;    (interactive)
;;    (setq leetcode-prefer-language (read-from-minibuffer "language? ")))
;;
;;  (defadvice! personal-leetcode-randomize-language ()
;;    :after #'leetcode
;;    (personal-choose-random-leetcode-language)))

#+end_src

** GCMH
#+begin_src emacs-lisp
(gcmh-mode 1)
#+end_src
** VLF
Load VLF mode when not much is happening
#+begin_src emacs-lisp
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src
* Programming
** C Family
Setup LSP-mode with clangd based on [[file:~/.emacs.d/modules/lang/cc/README.org::*Eglot with clangd][this]]
#+BEGIN_SRC elisp
;; (set-eglot-client! 'cc-mode '("clangd" "-j=3" "--clang-tidy"))

(setq lsp-clients-clangd-args '("-j=3"
                                "--background-index"
                                "--clang-tidy"
                                "--completion-style=detailed"
                                "--header-insertion=never"))
(after! lsp-clangd (set-lsp-priority! 'clangd 2))
#+END_SRC

Map <Space>ff to =ff-find-other-file= for Cpp
#+BEGIN_SRC emacs-lisp
(map! :mode 'cpp-mode :leader
      " ff" #'ff-find-other-file)
#+END_SRC

Org source blocks should use up to date cpp
#+begin_src emacs-lisp
(defvar org-babel-default-header-args:cpp '((:flags . "-std=c++20")))
#+end_src

(default) Formatter options for the C family
#+begin_src emacs-lisp
(set-formatter! 'clang-format
  '("clang-format"
    "-style={BasedOnStyle: llvm, IndentWidth: 2, SortIncludes: true, ColumnLimit: 100}"
    ("-assume-filename=%S" (or buffer-file-name mode-result "")))
  :modes '(cpp-mode c-mode))
#+end_src

*Note to self*
Can set the =C++= version of projects using directory local variables for clang flychecker
#+begin_quote
Open the root directory of your project in Dired with C-x d, and then type M-x add-dir-local-variable RET c++-mode RET flycheck-gcc-language-standard RET "c++11". This will create a .dir-locals.el file in the root directory of your project. Emacs reads this file whenever you visit a file from this directory or any subdirectory, and sets variables according to the rules in this file. Specifically, Emacs will now set the language standard for Flycheck syntax checking to C++ 11 for all C++ files in your project.
#+end_quote

*Another Note to self*
I have abbreviations to make coding in C++ less work in [[~/.doom.d/abbrev.el]]

** OR Tools
Useful stuff for working with linear programs and the like.

Hook AMPL relate files to [[https://github.com/dpo/ampl-mode][ampl-mode]].
#+BEGIN_SRC emacs-lisp
(setq auto-mode-alist
      (cons '("\\.mod$" . ampl-mode) auto-mode-alist))
(setq auto-mode-alist
      (cons '("\\.dat$" . ampl-mode) auto-mode-alist))
(setq auto-mode-alist
      (cons '("\\.ampl$" . ampl-mode) auto-mode-alist))
(setq auto-mode-alist
      (cons '("\\.ampl$" . ampl-mode) auto-mode-alist))
(setq interpreter-mode-alist
      (cons '("ampl" . ampl-mode)
            interpreter-mode-alist))
(autoload 'ampl-mode "ampl-mode" "Ampl editing mode." t)
#+END_SRC

Recommend previously used words in AMPL mode
#+BEGIN_SRC emacs-lisp
(add-hook! ampl-mode
  (set-company-backend! 'ampl-mode 'company-dabbrev))
#+END_SRC
** Rust
Configs for coding in the rust programming language.

Set ~RUST_SRC_PATH~ for racer:
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (let* ((rust-lib-path "/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library")
         (rust-full-path (concat (substitute-in-file-name "$HOME") rust-lib-path)))
    (setq racer-rust-src-path rust-full-path)))
#+END_SRC

Setup completion in rust
#+BEGIN_SRC emacs-lisp
(add-hook! rust-mode
  (set-company-backend! 'rust-mode '(company-capf company-dabbrev company-yasnippet)))
#+END_SRC

** Swift
Configurations for the swift programming language.

Setup =lsp-sourcekit= to work swift files...
#+BEGIN_SRC emacs-lisp
;; (after! lsp-sourcekit
;;   (setenv "SOURCEKIT_TOOLCHAIN_PATH" "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain")
;;   (setq lsp-sourcekit-executable (string-trim (shell-command-to-string "xcrun --find sourcekit-lsp"))))
#+END_SRC

Recommend previously used words in swift files to compensate for spotty sourcekit support:
#+BEGIN_SRC emacs-lisp
(add-hook! swift-mode
  (set-company-backend! 'swift-mode '(company-sourcekit company-dabbrev company-capf company-yasnippet)))
#+END_SRC

Add =swiftlint= as a linter in swift files
#+BEGIN_SRC elisp
(with-eval-after-load 'flycheck
  (flycheck-swiftlint-setup))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq flycheck-python-flake8-executable "~/Library/Python/3.8/bin/flake8"))
#+END_SRC

Which python is used:
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq python-shell-exec-path '("/usr/local/bin/python3"))
  (setq python-shell-remote-exec-path '("/usr/local/bin/python3")))
#+END_SRC

Map the commands for sending lines to REPL to something less painful
#+BEGIN_SRC emacs-lisp
(map! :mode 'python-mode :leader
      "ml" #'python-shell-send-statement
      "mr" #'python-shell-send-region
      "mf" #'python-shell-send-defun)
#+END_SRC

Stop the warning about native read line
#+begin_src emacs-lisp
(with-eval-after-load 'python
  (defun python-shell-completion-native-try ()
    "Return non-nil if can trigger native completion."
    (let ((python-shell-completion-native-enable t)
          (python-shell-completion-native-output-timeout
           python-shell-completion-native-try-output-timeout))
      (python-shell-completion-native-get-completions
       (get-buffer-process (current-buffer))
       nil "_"))))

(setq python-shell-completion-native-enable nil)
#+end_src

Set tab size and stuff
#+begin_src emacs-lisp
(add-hook 'python-mode-hook
      (lambda ()
        (setq indent-tabs-mode nil)
        (setq tab-width 4)
        (setq python-indent-offset 4)))
#+end_src

* Misc/Random
** Fun Stuff
 Fun Emacs things
 
 Zone mode screen saver after a good amount of idle time
 #+BEGIN_SRC emacs-lisp
 (require 'zone)
 (zone-when-idle 600) ;; 10 minutes
 #+END_SRC

Disable all non productive stuff (for lectures or presentations)
#+BEGIN_SRC emacs-lisp
(defun personal-look-professional ()
  "Disable all idle animations and related."
  (interactive)
  (huecycle-stop-idle)
  (huecycle-reset-all-faces-on-all-buffers)
  (zone-leave-me-alone))
#+END_SRC

Add rainbow to zone programs
#+BEGIN_SRC elisp
(setq zone-programs (vconcat [zone-rainbow] zone-programs))
#+END_SRC

Enable sound support
#+BEGIN_SRC elisp
(unless (and (fboundp 'play-sound-internal)
             (subrp (symbol-function 'play-sound-internal)))
  (require 'play-sound))
#+END_SRC

Set some faces to change color when idle
#+BEGIN_SRC elisp
(require 'huecycle)

(after! (huecycle doom-modeline hl-line company-box ewal)
  (huecycle-set-faces
   ;; rainbow stuff
   ((foreground . (doom-modeline-evil-normal-state
                   doom-modeline-evil-insert-state
                   doom-modeline-buffer-major-mode
                   line-number-current-line
                   doom-modeline-lsp-success
                   doom-modeline-panel
                   doom-modeline-info
                   ))
    :random-color-hue-range (0.0 1.0)
    :random-color-saturation-range (0.8 1.0)
    :random-color-luminance-range (0.5 0.8)
    :speed 0.5)
   ((foreground . region)
    :random-color-hue-range (0.0 1.0)
    :random-color-saturation-range (0.9 1.0)
    :random-color-luminance-range (0.5 0.8))
   ((background . company-tooltip-selection)
    :random-color-hue-range (0.0 1.0)
    :random-color-saturation-range (0.1 0.5)
    :random-color-luminance-range (0.1 0.25))
   ;; Non Rainbow stuff
   ;; ((background . hl-line)
   ;;  :color-list (,(ewal-load-color 'white -11) ,(ewal-load-color 'white -0))
   ;;  :next-color-func huecycle-get-next-list-color
   ;;  :speed 0.3
   ;;  :persist t)
   )
  (setq huecycle-buffers-to-huecycle-in
        (list
         #'current-buffer
         (lambda ()
           (company-box--get-buffer))))
  (huecycle-when-idle 1.0))
#+END_SRC

** Scratch Space
Space for random elisp
#+BEGIN_SRC elisp
;; (require 'random-theme)
(if IS-MAC
    (load "~/.doom.d/local_packages/random-theme/random-theme.el"))
;; mad hacky but too lazy to look into this

(if (and (display-graphic-p) IS-MAC)
    (defadvice! personal-random-theme-on-reload-last ()
      :after #'doom/quickload-session
      (random-theme-set-theme)))
;; (after! +doom-dashboard-mode
;;   (print "is running...?")
;;   (if IS-MAC (random-theme-set-theme)))

(defun personal-refresh-ewal-emacs-theme ()
  "Refreshes the ewal-doom-one theme based on current background"
  (interactive)
  (load-theme 'ewal-doom-one)
  (personal-make-fixed-pitch-shrink))

(message ".emacs.d dir not on master... should change that soon")

#+END_SRC

* Orgmode footer args
#+localWords: MacOS, PDFs, ampl, Config, Configs, sourcekit, flycheck
