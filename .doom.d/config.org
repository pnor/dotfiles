#+TITLE: Org Mode Configuration
#+AUTHOR: Phillip O'Reggio
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: hideblocks overview
#+BEGIN_SRC emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+END_SRC

* Preamble
Super early things
(Good for fixing/changing and bugfixes)
#+begin_src emacs-lisp
;; redefine this as eieio uses it but master depecrates it
(defun cl--generic-struct-tag (name &rest _)
  ;; Use exactly the same code as for `typeof'.
  `(if ,name (type-of ,name) 'null))
#+end_src

Functions used throughout the config

Only run the forms based on which OS

#+begin_src emacs-lisp
(defmacro when-macos (&rest forms)
  "Only run FORMS if OS is MacOS."
  (if IS-MAC
      `(mapc #'eval ',forms)))

(defmacro when-linux (&rest forms)
  "Only run FORMS if OS is Linux."
  (if IS-LINUX
      `(mapc #'eval ',forms)))
#+end_src
* General
** Private Information
Load some personal information
#+BEGIN_SRC emacs-lisp
(if (file-exists-p "~/.doom.d/Secret.el")
    (load! "Secret.el"))
#+END_SRC
** Library Functions
Functions used in other places in the configs
#+BEGIN_SRC emacs-lisp
;; Get a live xwidget buffer with url opened
(defun personal--xwidget-buffer (url)
  (xwidget-webkit-browse-url url)
  (let ((xwidget-buf (seq-find
                      (lambda (b) (eq (buffer-local-value 'major-mode b) 'xwidget-webkit-mode))
                      (buffer-list))))
    xwidget-buf))
#+END_SRC
** Font, Themes, and the General Look and Behavior
*** Fonts
Keeping all the font information in one place

Setting the main font
#+begin_src emacs-lisp
(when-macos
 (setq doom-font (font-spec :family "CozetteVector" :size 20)))

(when-linux
 (setq doom-font (font-spec :family "CozetteCrossedSevenVector" :size 18)))
;; (when-linux
;;  (setq doom-font (font-spec :family "More Perfect DOS VGA" :size 16)))
#+end_src
"CozetteCrossedSevenVector"
"More Perfect DOS VGA"

Make some faces use variable pitch
#+begin_src emacs-lisp
(custom-theme-set-faces
   'user
   '(line-number ((t (:inherit fixed-pitch))))
   '(line-numer-current-line ((t (:inherit fixed-pitch))))
   '(doom-modeline-buffer-major-mode ((t (:inherit fixed-pitch)))))
#+end_src

And change the font used for variable pitch fonts in org mode
#+begin_src emacs-lisp
(when-macos
 (setq personal-variable-pitch-font "Helvetica")
 (setq personal-fixed-pitch-font "MesloLGS Nerd Font"))

(when-linux
 (setq personal-variable-pitch-font "Roboto Mono")
;; (setq personal-fixed-pitch-font "CozetteCrossedSevenVector"))
 (setq personal-fixed-pitch-font "CozetteCrossedSevenVector"))

(set-face-attribute 'variable-pitch nil :family personal-variable-pitch-font)

(defun personal-fixup-fonts-org-mode ()
  (interactive)
  (set-face-attribute 'variable-pitch nil :family personal-variable-pitch-font)
  (set-face-attribute 'org-modern-symbol nil :family personal-fixed-pitch-font)
  (set-face-attribute 'org-block nil :family personal-fixed-pitch-font)
  (set-face-attribute 'org-table nil :family personal-fixed-pitch-font))

(after! org-modern
  (setq org-modern-table nil)
  (personal-fixup-fonts-org-mode))
#+end_src


Make fixed pitch not be a constant size, for Demap and such so certain fonts (comments in
particular) don't appear super large compared to everything else
#+begin_src emacs-lisp
(defun personal-make-fixed-pitch-shrink ()
  (interactive)
  (set-face-attribute 'fixed-pitch nil :height 'unspecified))

(personal-make-fixed-pitch-shrink)
(add-hook! prog-mode #'personal-make-fixed-pitch-shrink)
(add-hook! doom-load-theme-hook #'personal-make-fixed-pitch-shrink)
#+end_src

*** Look
Set ewal color location json
#+begin_src emacs-lisp
(after! ewal
  (setq ewal-json-file "~/.cache/wallust/colors.json"))
#+end_src

Set the color theme and font
#+BEGIN_SRC emacs-lisp
(when-macos
(setq doom-theme 'starry-transparent))

(when-linux
(setq doom-theme 'ewal-doom-vibrant))

;; Make comments brighter if using ewal
(setq ewal-doom-vibrant-brighter-comments t)
(setq ewal-doom-vibrant-comment-bg nil)

(when-linux
 (defun personal-make-ewal-comment-brighter ()
   (interactive)
   (set-face-attribute 'font-lock-comment-face nil :foreground (ewal-load-color 'green -0))
   (set-face-attribute 'org-block-begin-line nil :foreground (ewal-load-color 'green -0))
   (set-face-attribute 'org-block-end-line nil :foreground (ewal-load-color 'green -0))))
#+END_SRC

Cursor color
#+begin_src emacs-lisp
(setq evil-normal-state-cursor '(box "#528AF2")
      evil-insert-state-cursor '(bar "#528AF2")
      evil-visual-state-cursor '(hollow "#FDDC87")
      evil-operator-state-cursor '(evil-half-cursor "#528AF2")
      evil-replace-state-cursor '(hbar "#FDDC87"))
#+end_src

Make the emacs frame transparent because I like my laptop background üôÉ
#+BEGIN_SRC emacs-lisp
(defun personal-set-alpha-background-frame-params ()
  (let ((bg-transparency 0.75))
    (set-frame-parameter (selected-frame) 'alpha-background bg-transparency)
    (add-to-list 'default-frame-alist `(alpha-background . ,bg-transparency))))

(add-hook 'doom-load-theme-hook #'personal-set-alpha-background-frame-params)
#+END_SRC

And some functions to manipulate transparency on the frame
#+begin_src emacs-lisp
(defun personal-set-alpha-background-on-frame ()
  (interactive)
  (let ((alpha (read-number "Enter transparency (0.0-1.0): ")))
    (set-frame-parameter (selected-frame) 'alpha-background alpha)))
#+end_src

Control size of emacs on startup (mainly for macos since I use WM on linux)
#+begin_src emacs-lisp
(when-macos
 (setq initial-frame-alist '((top . 100) (left . 400) (width . 100) (height . 40))))
#+END_SRC

Set cursor color
#+begin_src emacs-lisp
;; TODO
;; (evil-set-cursor-color (ewal-get-color cyan))
#+end_src

Show Line numbers
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type t)
#+END_SRC

Modify the appearance of the mode-line
#+BEGIN_SRC elisp
(setq doom-modeline-major-mode-icon t)
#+END_SRC

*** Behavior
Add a fill column to prevent long lines (116 is the width of the vertical monitor)
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 100)
#+END_SRC

and automatically break long lines in source code buffers and org mode files
#+BEGIN_SRC emacs-lisp
(add-hook! prog-mode (auto-fill-mode t))
#+END_SRC

Show a message when doing garbage collection
#+BEGIN_SRC emacs-lisp
;; (setq garbage-collection-messages t)
#+END_SRC

Have evil-mode treat emacs /symbols/ as words instead of by character
(symbol definition changes based on the language)
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
    (defalias #'forward-evil-word #'forward-evil-symbol)
    ;; make evil-search-word look for symbol rather than word boundaries
    (setq-default evil-symbol-word-search t))

#+END_SRC

Enable pixel scrolling precision
#+BEGIN_SRC emacs-lisp
(pixel-scroll-precision-mode 1)
(setq pixel-scroll-precision-use-momentum t)
#+END_SRC

Let search look at invisible content (useful in org mode)
#+begin_src emacs-lisp
(setq search-invisible t)
#+end_src

** Splash Screen Edits
Function for making random wave art for the banner
#+begin_src emacs-lisp :lexical t

(setq personal-wave-param-low 1)
(setq personal-wave-param-high 100)

(defun personal-frac-function (x)
  (if (>= x 0)
      (- x (floor x))
    (* -1 (- (* -1 x) (floor (* -1 x))))))

(defun personal-wave-function-1 (x y a b c d)
  (let* ((highest-magnitude (+ 1 1))
         (wave-result (+ (sin (* (/ a b) x)) (sin (* (/ c d 1.0) y))))
         (normalized (/ (+ wave-result highest-magnitude) (* 2 highest-magnitude))))
    normalized))

(defun personal-wave-function-2 (x y a b c d)
  (let* ((highest-magnitude 1)
         (wave-result (sin (* x y (/ a c 1.0) (/ b d 1.0))))
         (normalized (/ (+ wave-result highest-magnitude) (* 2 highest-magnitude))))
    normalized))

(defun personal-wave-function-3 (x y a b c d)
  (let* ((highest-magnitude 1)
         (wave-result (sin (* x y (* (/ a 1) c 1.0) (/ b d 1.0))))
         (normalized (/ (+ wave-result highest-magnitude) (* 2 highest-magnitude))))
    normalized))

(defun personal-wave-function-4 (x y a b c d)
  (let* ((highest-magnitude 1)
         (wave-result (cos (* (log (* (- (* 2 pi) x) c )) (log (* (- (* 2 pi) y) b)) a d 0.01)))
         (normalized (/ (+ wave-result highest-magnitude) (* 2 highest-magnitude))))
    normalized))

(defun personal-wave-function-5 (x y a b c d)
  (let* ((highest-magnitude 1)
         (base-number (personal-frac-function
                       (+
                        (* (* 0.8 b) (sin (* a y)))
                        (* (* 0.8 d) (sin (* c x))))))
         (wave-result (* 2 (- base-number 0.5)))
         (normalized (/ (+ wave-result highest-magnitude) (* 2 highest-magnitude))))
    normalized))

(personal-wave-function-3 1 1 1 1 1 1)

(defun personal-choose-wave-func (wave-funcs)
  "Choose random function from WAVE-FUNCS"
  (nth (random (length wave-funcs)) wave-funcs))

(defun personal-intensity-to-character (intensity)
  "Maps INTENSITY to a character from .,-~:;=!*#$@"
  (pcase intensity
    ((pred (lambda (x) (<= x (* 1 0.077))))
     ?\s)
    ((pred (lambda (x) (<= x (* 2 0.077))))
     ?\s)
    ((pred (lambda (x) (<= x (* 3 0.077))))
     ?\s)
    ((pred (lambda (x) (<= x (* 4 0.077))))
     ?.)
    ((pred (lambda (x) (<= x (* 5 0.077))))
     ?-)
    ((pred (lambda (x) (<= x (* 6 0.077))))
     ?:)
    ((pred (lambda (x) (<= x (* 7 0.077))))
     ?\;)
    ((pred (lambda (x) (<= x (* 8 0.077))))
     ?=)
    ((pred (lambda (x) (<= x (* 9 0.077))))
     ?!)
    ((pred (lambda (x) (<= x (* 10 0.077))))
     ?*)
    ((pred (lambda (x) (<= x (* 11 0.077))))
     ?#)
    ((pred (lambda (x) (<= x (* 12 0.077))))
     ?$)
    ((pred (lambda (x) (<= x (* 13 0.077))))
     ?@)
    (x
     ?\@)))

(defun personal-scale-to-2pi (cur max)
  "Scales a number CUR between [0, max) to [0, 2pi)"
  (* (/ cur max 1.0) (* float-pi 2)))

(defun personal-make-ascii-wave-art (height width)
  (let ((output-lines (mapcar (lambda (c) (make-string width c)) (make-list height ?.)))
        (wave-func (personal-choose-wave-func
                    '(personal-wave-function-1 personal-wave-function-2 personal-wave-function-3
                      personal-wave-function-4 personal-wave-function-5)))
        (a (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low))
        (b (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low))
        (c (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low))
        (d (+ (random (- personal-wave-param-high personal-wave-param-low)) personal-wave-param-low)))
    (cl-loop for i from 0 to (- height 1) do
             (cl-loop for j from 0 to (- width 1) do
                      (let* ((x (personal-scale-to-2pi j width))
                             (y (personal-scale-to-2pi i height))
                             (intensity (apply wave-func `(,x ,y ,a ,b ,c ,d)))
                             (character (personal-intensity-to-character intensity)))
                        (aset (nth i output-lines) j character))))

    output-lines))

(after! +doom-dashboard-mode-hook
  (personal-make-ewal-comment-brighter))
#+end_src

Custom Banner text
#+begin_src emacs-lisp :lexical t
(setq personal-wave-width 60)
(setq personal-wave-height 30)

(defun personal-custom-splash-ascii ()
  (let* ((banner
          (personal-make-ascii-wave-art personal-wave-height personal-wave-width))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(setq +doom-dashboard-ascii-banner-fn #'personal-custom-splash-ascii)
#+end_src

Remove splash screen menu options I don't use
#+begin_src emacs-lisp

(defun personal-change-doom-dashboard-options ()
  "Change dashboard options for start screen"
  (require 'nerd-icons)
  (after! nerd-icons
    (setq +doom-dashboard-menu-sections
          '(("Resume" :icon
             (nerd-icons-octicon "nf-oct-history" :face 'doom-dashboard-menu-title)
             :when
             (cond
              ((featurep! :ui workspaces)
               (file-exists-p
                (expand-file-name persp-auto-save-fname persp-save-dir)))
              ((require 'desktop nil t)
               (file-exists-p
                (desktop-full-file-name))))
             :face
             (:inherit
              (doom-dashboard-menu-title bold))
             :action doom/quickload-session)
            ("Config" :icon
             (nerd-icons-octicon "nf-oct-tools" :face 'doom-dashboard-menu-title)
             :when
             (file-directory-p doom-private-dir)
             :action doom/open-private-config)))))

(personal-change-doom-dashboard-options)
#+end_src

Last Crash Info (for MacOS)
(unused now since I don't use Emacs on MacOS much
#+begin_src emacs-lisp
;; (defun personal--last-crash-delta (crash-log-dir emacs-crash-cache-file)
;;   "Computes time since last crash.
;; Return result as a numeric number that needs to be converted to human readable string using `ts-human-format-duration'.
;; 
;; CRASH-LOG-DIR is the directory where Emacs crash log is located (used to run touch).
;; 
;; EMACS-CRASH-CACHE-file is a file (may not exist yet) that stores the time of the latest crash. Is
;; used when the CRASH-LOG-DIR has no information for the last crash time, and is created/updated on
;; each parse."
;;   (require 'ts)
;;   (let* ((dir-name (expand-file-name crash-log-dir))
;;          (last-crash-log (shell-command-to-string (format "ls -r %s | rg -i emacs | head -1"
;;                                                           dir-name))))
;;     (if (length= last-crash-log 0)
;;         (personal--use-crash-cache (expand-file-name emacs-crash-cache-file))
;;       (personal--use-crash-log
;;        (expand-file-name crash-log-dir)
;;        (expand-file-name emacs-crash-cache-file)))))
;; 
;; (defun personal--use-crash-cache (emacs-crash-cache-file)
;;   (unless (file-exists-p emacs-crash-cache-file)
;;     (write-region (shell-command-to-string "date -R") nil emacs-crash-cache-file))
;;   (let ((last-crash-string (with-temp-buffer
;;                         (insert-file-contents emacs-crash-cache-file)
;;                         (buffer-string))))
;;     (personal--compute-delta last-crash-string)))
;; 
;; (defun personal--use-crash-log (log-file cache-file)
;;   (let ((last-crash-string
;;          (shell-command-to-string (format "date -r %s -R" log-file))))
;;     (write-region last-crash-string nil cache-file)
;;     (personal--compute-delta last-crash-string)))
;; 
;; (defun personal--compute-delta (last-crash-time-string)
;;   (ts-diff (ts-parse (shell-command-to-string "date -R")) (ts-parse last-crash-time-string)))
;; 
;; (defun personal--is-longest-no-crash-time (delta best-time-file)
;;   "Return `t' if DELTA is bigger than the number in BEST-TIME-FILE.
;; Also handles updating the number if it is bigger, or creating it if it doesn't exist."
;;   (let ((best-time-file-name (expand-file-name best-time-file)))
;;     (unless (file-exists-p best-time-file-name)
;;       (write-region "0" nil best-time-file-name))
;;     (let ((best-delta (string-to-number (with-temp-buffer
;;                         (insert-file-contents best-time-file-name)
;;                         (buffer-string)))))
;;       (if (> delta best-delta)
;;           (progn
;;             ;; write that to file instead
;;             (write-region (number-to-string delta) nil best-time-file-name)
;;             ;; return t
;;             t)
;;         nil))))
;; 
;; 
;; (defun doom-last-crash-line ()
;;   "Say how long since Emacs last crashed.
;; BEST-TIME-NAME is optional and specifies absolute path to file that contains the longest time Emacs"
;;   (let* ((delta (personal--last-crash-delta "~/Library/Logs/DiagnosticReports" "~/.doom.d/splash-last-crash.txt"))
;;          (delta-string (ts-human-format-duration delta)))
;;     (if (personal--is-longest-no-crash-time delta "~/.doom.d/splash-longest-last-crash.txt")
;;         (format "%s since last incident! (NEW RECORD!)" delta-string)
;;       (format "%s since last incident!" delta-string))))
;; 
;; (defun doom-dashboard-phrase ()
;;   "Get a splash phrase, flow it over multiple lines as needed, and make fontify it."
;;   (mapconcat
;;    (lambda (line)
;;      (+doom-dashboard--center
;;       +doom-dashboard--width
;;       (with-temp-buffer
;;         (insert-text-button
;;          line
;;          'action
;;          (lambda (_) (+doom-dashboard-reload t))
;;          'face 'doom-dashboard-menu-title
;;          'mouse-face 'doom-dashboard-menu-title
;;          'help-echo "Last crash"
;;          'follow-link t)
;;         (buffer-string))))
;;    (split-string
;;     (with-temp-buffer
;;       (insert (doom-last-crash-line))
;;       (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
;;       (fill-region (point-min) (point-max))
;;       (buffer-string))
;;     "\n")
;;    "\n"))
;; 
;; ;; Only place this message if ts is available (avoid startup errors)
;; (when (require 'ts nil 'noerror)
;;   (defadvice! doom-dashboard-widget-loaded-with-phrase ()
;;     :override #'doom-dashboard-widget-loaded
;;     (setq line-spacing 0.2)
;;     (insert
;;      "\n\n"
;;      (propertize
;;       (+doom-dashboard--center
;;        +doom-dashboard--width
;;        (doom-display-benchmark-h 'return))
;;       'face 'doom-dashboard-loaded)
;;      "\n"
;;      (doom-dashboard-phrase)
;;      "\n")))
;; 
;; (if IS-MAC
;;     (add-hook 'doom-load-theme-hook #'personal-change-doom-dashboard-options))
#+end_src

** Useful Functions
*** New Functions
Toggle the transparency of emacs
#+BEGIN_SRC emacs-lisp
;; Initialize transparency to `true`

;; TODO change this to not use global state, but instead use frame-local state

(put 'cfg-transparency 'state t)

(defun personal-toggle-transparency ()
  "Toggle the transparency of emacs"
  (interactive)
  (if (get 'cfg-transparency 'state)
      (progn
        (set-frame-parameter (selected-frame) 'alpha '(100 100))
        (put 'cfg-transparency 'state nil))
    (progn
      (set-frame-parameter (selected-frame) 'alpha '(85 85))
      (put 'cfg-transparency 'state t))
    ))
#+END_SRC

Control size of Emacs frame:
#+BEGIN_SRC emacs-lisp
(defun personal-frame-change-size (width height)
  "Modify size of window frame by increasing it by WIDTH and HEIGHT."
  (let ((cur-width (frame-width (window-frame)))
        (cur-height (frame-height (window-frame))))
    (set-frame-size (window-frame) (+ cur-width width) (+ cur-height height))))

(defun personal-frame-full-screen ()
  "Toggle frame to be fullscreen."
  (interactive)
  (toggle-frame-fullscreen))

(defun personal-frame-increase-width ()
  "Increase frame width by 1."
  (interactive)
  (personal-frame-change-size 1 0))

(defun personal-frame-decrease-width ()
    "Decrease frame width  by 1."
    (interactive)
    (personal-frame-change-size -1 0))

(defun personal-frame-increase-height ()
    "Increase frame height by 1."
    (interactive)
    (personal-frame-change-size 0 1))

(defun personal-frame-decrease-height ()
    "Decrease frame height by 1."
    (interactive)
    (personal-frame-change-size 0 -1))

(defun personal-frame-increase-diag ()
    "Increase frame width and height by 1."
    (interactive)
    (personal-frame-change-size 1 1))

(defun personal-frame-decrease-diag ()
    "Decrease frame width and height by 1."
    (interactive)
    (personal-frame-change-size -1 -1))
#+END_SRC

Control position of emacs frame:
#+BEGIN_SRC emacs-lisp
(defun personal-frame-move (down right)
  "Move window frame by DOWN and RIGHT."
  (pcase (frame-position)
    (`(,x . ,y) (set-frame-position (selected-frame) (+ x right) (+ y down)))))

(defun personal-move-frame-down-30 ()
  "Move window frame down 30."
  (interactive)
  (personal-frame-move 30 0))

(defun personal-move-frame-down-5 ()
  "Move window frame down 5."
  (interactive)
  (personal-frame-move 5 0))

(defun personal-move-frame-up-30 ()
  "Move window frame up 30."
  (interactive)
  (personal-frame-move -30 0))

(defun personal-move-frame-up-5 ()
  "Move window frame down 5."
  (interactive)
  (personal-frame-move -5 0))

(defun personal-move-frame-left-30 ()
  "Move window frame left 30."
  (interactive)
  (personal-frame-move 0 -30))

(defun personal-move-frame-left-5 ()
  "Move window frame left 5."
  (interactive)
  (personal-frame-move 0 -5))

(defun personal-move-frame-right-30 ()
  "Move window frame right 30."
  (interactive)
  (personal-frame-move 0 30))

(defun personal-move-frame-right-5 ()
  "Move window frame right 5."
  (interactive)
  (personal-frame-move 0 5))
#+END_SRC

Change fill-column
#+BEGIN_SRC elisp
#+END_SRC

Open up terminal in narrow vertical split
#+BEGIN_SRC emacs-lisp
(defun personal-sterm ()
  "Opens a terminal in a split on the left"
  (interactive)
  (require 'vterm)
  (progn
    (split-window-right 45)
    (+vterm/here t)))
#+END_SRC

Open up google in a split
#+BEGIN_SRC elisp
(defun personal-google-split ()
  "Open google in vertical split using xwidget-webkit"
  (interactive)
  (let ((google-url "https://www.google.com")
        (xwidget-buffer (lambda ()
                          (seq-find
                           (lambda (b) (eq (buffer-local-value 'major-mode b) 'xwidget-webkit-mode))
                           (buffer-list)))))
    (split-window-right)
    (xwidget-webkit-browse-url google-url)
    (switch-to-buffer (funcall xwidget-buffer))))

(defun personal-google-here ()
  "Open google in current buffer"
  (interactive)
  (let ((google-url "https://www.google.com"))
    (personal--xwidget-buffer google-url)))
#+END_SRC

Open google in window with xwidget
#+BEGIN_SRC elisp
(defun personal-open-google ()
  "Open google in in window using xwidget-webkit"
  (interactive)
  (let ((google-url "https://www.google.com"))
    (xwidget-webkit-browse-url google-url)))
#+END_SRC

*** Changing Old Ones
nothing yet

** Keybindings and Custom Commands
*** Keybindings
jk -> Escape
#+begin_src emacs-lisp
(require 'corfu)
(require 'key-chord)

(defun personal-jk-escape ()
  (interactive)
  (corfu-quit)
  (evil-normal-state))

(key-chord-mode 1)
(key-chord-define evil-insert-state-map  "jk" #'personal-jk-escape)
#+end_src

Using Doom Evil
#+begin_src emacs-lisp
(setq-default evil-escape-key-sequence "jk")
#+end_src

Make moving around splits as easy as pressing space.
#+BEGIN_SRC emacs-lisp
(map! :leader :mode 'global
  "h" #'evil-window-left
  "l" #'evil-window-right
  "j" #'evil-window-down
  "k" #'evil-window-up

  "H" #'+evil/window-move-left
  "L" #'+evil/window-move-right
  "K" #'+evil/window-move-up
  "J" #'+evil/window-move-down
  )
#+END_SRC

Use dirvish over find-file
#+BEGIN_SRC emacs-lisp
(defun personal-dirvish-find-file (filename &optional wildcards)
  (interactive
   (find-file-read-args "üîç Open: "
                        (confirm-nonexistent-file-or-buffer)))
  (dirvish-dwim filename))

(map! :leader :mode 'global
 "." #'personal-dirvish-find-file
  )
#+END_SRC

Change =;= to =:= (for vim ex mode)
#+BEGIN_SRC emacs-lisp
(map! :nv
  ";" 'evil-ex
  )
#+END_SRC

Map "s" to the sneak motion
#+BEGIN_SRC emacs-lisp
;; Unbind "s" from everything else
(map!
 :map evil-normal-state-map
 "s" nil
 "S" nil)

;; Then bind it
(map!
 :nv "s" #'evil-avy-goto-char-2-below
 :n "S" #'evil-avy-goto-char-2-above)
#+END_SRC

*** Custom ex Commands
~:G~ for magit status
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "G" #'magit-status)
#+END_SRC

~:S~ to search google and ~:SS~ to open google in current frame
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "S" #'personal-google-split)
(evil-ex-define-cmd "SS" #'personal-google-here)
#+END_SRC

~:E~ to search google with eww
#+BEGIN_SRC emacs-lisp
(defun personal-eww-google ()
  (interactive)
  (let* ((query (read-from-minibuffer "Search for: "))
         (url-extension (replace-regexp-in-string " " "+" query )))
  (eww (concat "https://www.google.com/search?q=" url-extension))))

(evil-ex-define-cmd "E" #'personal-eww-google)
#+END_SRC

~:Fexplore~ to open a project drawer
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "Fexplore" #'treemacs)
#+END_SRC

~:PRReview~ to diff between two branches
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "PRReview" #'magit-diff-range)
#+END_SRC

~:STerm~ to open terminal in a split
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "STerm" #'personal-sterm)
#+END_SRC

** Memory Usage
Let Emacs use more memory for reading and garbage collection
#+begin_src elisp
;; 100 mb
(setq gc-cons-threshold 100000000)
(setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src

** Fixing Things
A place for hacks and functions to fix fires

(nothing right now)

** Abbrevs
Manage abbreviations
#+BEGIN_SRC emacs-lisp
(quietly-read-abbrev-file (expand-file-name "~/.doom.d/abbrev.el"))
#+END_SRC

* Modes
** Text Mode
Mode for human readable text

Recommend words when typing in text mode files:
#+BEGIN_SRC emacs-lisp
(defun personal-setup-completion-for-text-mode ()
  (interactive)
  (setq-local
   completion-at-point-functions (list (cape-capf-super
                                        #'cape-dict
                                        #'cape-dabbrev
                                        #'cape-emoji) #'cape-file)))

(add-hook! text-mode #'personal-setup-completion-for-text-mode)
#+END_SRC

** Org Mode
*** Look
Use org modern mode
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)
#+END_SRC

Set the org directory for org related files
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/agenda")
#+END_SRC

Make org-mode documents look a little nicer by hiding markers and showing symbols
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
(setq org-pretty-entities t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (setq
;;     org-superstar-headline-bullets-list '("‚Åñ" "‚óâ" "‚óã" "‚ú∏" "‚úø")
;; )
#+END_SRC

_Snippets to prettify Org mode based on this:_ [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][Beautifying Org Mode in Emacs]]:

Make org-mode files use variable pitch fonts to look more like text documents
([[*Fonts][See this]])

Files can opt out by having this at the *end* of the file:
#+BEGIN_EXAMPLE org
;; Local Variables:
;; eval: (variable-pitch-mode 0)
;; End:
#+END_EXAMPLE

*** Functionality
Add =proselint= to lint org-mode
#+begin_src elisp
(setq flycheck-proselint-executable "~/Library/Python/3.8/bin/proselint")
#+end_src

Setup =org-download=, which makes the process of putting images into orgmode much easier
Put downloaded images into an =images= directory and include timestamp. Use the command =pngpaste= to get the image
from the clipboard.
#+begin_src emacs-lisp
(after! org-download
  (setq org-download-method 'directory)
  (setq-default org-download-image-dir "images")
  (setq org-download-timestamp "%Y%m%d-%H%M%S_")
  (setq org-download-screenshot-method "/usr/local/bin/pngpaste %s"))
#+end_src

Advice =org-fancy-priorities-mode= which sometimes errors since =org-download= hasn't loaded yet
#+begin_src emacs-lisp
(defadvice! personal--load-org-download-with-fancy-priorities ()
  :before #'org-fancy-priorities-mode
  (require 'org-download))
#+end_src

Allow pasting of images with control over the width, and bind it to keybind
#+begin_src emacs-lisp
(defun org-download-screenshot-with-size ()
  "Prompt user for a width to paste the image. Only lasts for this one function"
  (interactive)
  (let ((width (read-number "Enter width: ")) (prev-width org-download-image-html-width))
    (progn
      (setq org-download-image-html-width width)
      (org-download-screenshot)
      (setq org-download-image-html-width prev-width))))

(map! :mode 'org-mode :leader
      "v" #'org-download-screenshot-with-size)
#+end_src

Make drag-and-drop of images work with dired (untested)
#+BEGIN_SRC emacs-lisp
;; Drag-and-drop to `dired`
(add-hook 'dired-mode-hook 'org-download-enable)
#+END_SRC

Make latex previews nice and big
#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 3.0)))
#+END_SRC

*** Hooks
Apply all org mode hook in one place
#+begin_src emacs-lisp
(defun personal-org-mode-hook-func ()
  (variable-pitch-mode)
  (personal-make-fixed-pitch-shrink)
  (auto-fill-mode t)
  (set-company-backend! 'org-mode 'company-dabbrev 'company-ispell)
  (org-modern-mode)
  (personal-fixup-fonts-org-mode))

(add-hook! org-mode #'personal-org-mode-hook-func)
#+end_src
** Org Journal
Encrypt the journal (?)
#+BEGIN_SRC elisp
;; ...
#+END_SRC

Set the dir
#+BEGIN_SRC elisp
(setq org-journal-dir "~/Dropbox/agenda/journal")
#+END_SRC

** Ivy
Config for the search engine, Ivy.

Allow fuzzy searches to make it easier to find matches with less thought.
#+BEGIN_SRC emacs-lisp
(setq ivy-re-builders-alist
      '((t . ivy--regex-fuzzy)))
#+END_SRC

Interactive functions to make toggling fuzzy search and strict search easier
#+BEGIN_SRC emacs-lisp
(defun personal-set-fuzzy-ivy ()
  "Make ivy use fuzzy searching"
  (interactive)
  (setq ivy-re-builders-alist
        '((t . ivy--regex-fuzzy))))

(defun personal-set-strict-ivy ()
  "Make ivy use more strict searching"
  (interactive)
  (setq ivy-re-builders-alist
        '((t . ivy--regex))))
#+END_SRC

** Working with PDFs
Make PDFs look sharper on MacOS
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq pdf-view-use-scaling t pdf-view-use-imagemagick nil))
#+END_SRC

** Corfu
Make the corfu frame not transparent
#+BEGIN_SRC emacs-lisp
(after! corfu
  (push '(alpha-background . 0.95) corfu--frame-parameters))
#+END_SRC

Corfu tab and go
#+begin_src emacs-lisp
(after! corfu
  (setq corfu-cycle t) ;; Enable cycling for `corfu-next/previous'
  (setq corfu-preselect 'prompt) ;; Always preselect the prompt
  ;; Tab for complete
  (map! :map corfu-map
        "TAB" #'corfu-next
        "S-TAB" #'corfu-previous))
#+end_src

The delay
#+begin_src emacs-lisp
(after! corfu
  (setq corfu-auto-delay 0.016))
#+end_src

Completion in progamming modes
#+begin_src emacs-lisp
(after! lsp-mode
  (defun personal-coding-completion ()
    (interactive)
    "Setup completion when coding with ‚Äòcorfu‚Äô and ‚Äòcape‚Äô."
    (setq-local
     completion-at-point-functions (list (cape-capf-super
                                          #'lsp-completion-at-point
                                          #'yasnippet-capf) #'cape-dabbrev #'cape-file)))

    ;; When opening a file after lsp is running ...
    (add-hook 'lsp-after-open-hook #'personal-coding-completion)
    ;; Opening a file for the first time
    (add-hook 'lsp-after-initialize-hook #'personal-coding-completion)
    ;; ...
(add-hook 'prog-mode-hook 'personal-coding-completion)
    )

#+end_src

Modified completion to lessen load
#+begin_src emacs-lisp
(after! (corfu orderless-)
  (defun orderless-fast-dispatch (word index total)
    (and (= index 0) (= total 1) (length< word 4)
         (cons 'orderless-literal-prefix word)))

  (orderless-define-completion-style orderless-fast
    (orderless-style-dispatchers '(orderless-fast-dispatch))
    (orderless-matching-styles '(orderless-literal orderless-regexp)))

  (defun personal-orderless-fast-lambda ()
    (setq-local completion-styles '(orderless-fast basic)
                completion-category-overrides nil
                completion-category-defaults nil))

  (add-hook 'corfu-mode-hook #'personal-orderless-fast-lambda))
#+end_src

Redefine the =lsp-completion-mode= to NOT add =lsp-completion-at-point= to =completion-at-point-functions=
on entering the mode to use the cape settings
#+begin_src  emacs-lisp
(define-minor-mode lsp-completion-mode
  "Toggle LSP completion support."
  :group 'lsp-completion
  :global nil
  :lighter ""
  (let ((completion-started-fn (lambda (&rest _)
                                 (setq-local lsp-inhibit-lsp-hooks t)))
        (after-completion-fn (lambda (result)
                               (when (stringp result)
                                 (lsp-completion--clear-cache))
                               (setq-local lsp-inhibit-lsp-hooks nil))))
    (cond
     (lsp-completion-mode
      (make-local-variable 'completion-at-point-functions)
      ;; Ensure that `lsp-completion-at-point' the first CAPF to be tried,
      ;; unless user has put it elsewhere in the list by their own
      ;; NOTE remove this
      ;; (add-to-list 'completion-at-point-functions #'lsp-completion-at-point)
      (make-local-variable 'completion-category-defaults)
      (setf (alist-get 'lsp-capf completion-category-defaults) '((styles . (lsp-passthrough))))
      (make-local-variable 'completion-styles-alist)
      (setf (alist-get 'lsp-passthrough completion-styles-alist)
            '(lsp-completion-passthrough-try-completion
              lsp-completion-passthrough-all-completions
              "Passthrough completion."))

      (cond
       ((equal lsp-completion-provider :none))
       ((and (not (equal lsp-completion-provider :none))
             (fboundp 'company-mode))
        (setq-local company-abort-on-unique-match nil)
        (company-mode 1)
        (setq-local company-backends (cl-adjoin 'company-capf company-backends :test #'equal)))
       (t
        (lsp--warn "Unable to autoconfigure company-mode.")))

      (when (bound-and-true-p company-mode)
        (add-hook 'company-completion-started-hook
                  completion-started-fn
                  nil
                  t)
        (add-hook 'company-after-completion-hook
                  after-completion-fn
                  nil
                  t))
      (add-hook 'lsp-unconfigure-hook #'lsp-completion--disable nil t))
     (t
      (remove-hook 'completion-at-point-functions #'lsp-completion-at-point t)
      (setq-local completion-category-defaults
                  (cl-remove 'lsp-capf completion-category-defaults :key #'cl-first))
      (setq-local completion-styles-alist
                  (cl-remove 'lsp-passthrough completion-styles-alist :key #'cl-first))
      (remove-hook 'lsp-unconfigure-hook #'lsp-completion--disable t)
      (when (featurep 'company)
        (remove-hook 'company-completion-started-hook
                     completion-started-fn
                     t)
        (remove-hook 'company-after-completion-hook
                     after-completion-fn
                     t))))))
#+end_src

** Flycheck
Set python path
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq flycheck-json-python-json-executable "/usr/local/bin/python3"))
#+END_SRC

handle next checkers after =lsp=
#+begin_src emacs-lisp
(defvar-local personal-flycheck-local-cache nil)

(defun personal-flycheck-checker-get (fn checker property)
  (or (alist-get property (alist-get checker personal-flycheck-local-cache))
      (funcall fn checker property)))

(advice-add 'flycheck-checker-get :around 'personal-flycheck-checker-get)

(add-hook 'lsp-managed-mode-hook
          (lambda ()
            (when (derived-mode-p 'sh-mode)
              (setq personal-flycheck-local-cache '((lsp . ((next-checkers . (sh-posix-bash)))))))
            (when (derived-mode-p 'c++-mode)
              (setq personal-flycheck-local-cache '((lsp . ((next-checkers . (c/c++-cppcheck)))))))))

#+end_src

** Evil-snipe mode
Disable =evil-snipe= mode to use =evil-avy-goto-char-2-below=
#+BEGIN_SRC emacs-lisp
(remove-hook 'doom-first-input-hook #'evil-snipe-mode)
#+END_SRC

** Evil quickscope
Always turn on quick scope in programming modes
#+BEGIN_SRC elisp
(add-hook 'prog-mode-hook 'turn-on-evil-quickscope-always-mode)
#+END_SRC

Disable font for second matches, and make the letter be bold for first matches
#+BEGIN_SRC elisp
(custom-theme-set-faces
   'user
   '(evil-quickscope-first-face ((t (:inherit unspecified :weight semibold))))
   '(evil-quickscope-second-face ((t (:inherit unspecified :weight unspecified)))))
#+END_SRC

** Floatbuf
Set floatbuf frame parameters
#+begin_src emacs-lisp
(after! floatbuf
  (push '(alpha . 100) floatbuf-frame-params)
  (push '(alpha-background . 0.65) floatbuf-frame-params)
  (if (not IS-MAC)
      (push '(parent-frame . nil) floatbuf-frame-params)))
#+end_src

#+RESULTS:
: ((parent-frame) (alpha-background . 0.65) (alpha . 100) (parent-frame) (alpha-background . 0.65) (alpha . 100) (vertical-scroll-bars) (tool-bar-lines . 0) (menu-bar-lines . 0) (buffer-predicate . doom-buffer-frame-predicate))

    Add key mappings for floating buffers
#+BEGIN_SRC emacs-lisp
(require 'floatbuf)

(after! floatbuf
  ;; with buffer
  (defun personal-floatbuf-with-buffer ()
    "Create floating buffer with the current buffer."
    (interactive)
    (floatbuf-make-floatbuf))
  ;; with terminal
  (defun personal-floatbuf-with-terminal ()
    "Create floating buffer with the a terminal."
    (interactive)
    (floatbuf-make-floatbuf)
    (+vterm/here nil))
  ;; scratch buffer
  (defun personal-floatbuf-with-scratch ()
    "Create floating buffer with the a scratch buffer"
    (interactive)
    (floatbuf-make-floatbuf-with-buffer (get-buffer "*scratch*")))
  ;; Epaint
  (defun personal-floatbuf-with-epaint ()
    "Create floating buffer with an epaint buffer"
    (interactive)
    (floatbuf-make-floatbuf)
    (epaint))
  ;; web browser
  (defun personal-floatbuf-with-xwidget ()
    "Create floating buffer with the xwidget"
    (interactive)
    (floatbuf-make-floatbuf)
    (personal-google-here))
  ;; mapping
  (map! :leader :mode 'global
        "fbS" #'personal-floatbuf-with-xwidget
        "fbe" #'personal-floatbuf-with-epaint
        "fbf" #'floatbuf-make-floatbuf
        "fbs" #'personal-floatbuf-with-scratch
        "fbt" #'personal-floatbuf-with-terminal))
#+END_SRC

** Lsp mode
Make =lsp-ui= frame not transparent
#+BEGIN_SRC elisp
(after! lsp-ui
  (push '(alpha . 100) lsp-ui-doc-frame-parameters))
#+END_SRC

Show more of the lsp ui
#+begin_src emacs-lisp
(setq lsp-headerline-breadcrumb-enable t)

#+end_src

Disable =lsp-ui-doc=
#+begin_src emacs-lisp
(after! lsp-ui
  (setq lsp-ui-doc-enable nil))
#+end_src

*** Emacs lsp booster
Something that makes lsp faster by wrapping it in an executable

https://github.com/blahgeek/emacs-lsp-booster

Note that if there is an issue with the ~emacs-lsp-booster~, then it will manifest as an issue running
the lsp server!!
If you have issues in the future, try commenting this out and see how it runs

Use emacs-lsp-booster if its on path
#+begin_src emacs-lisp
(when (executable-find "emacs-lsp-booster")
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))

  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))

  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command))
#+end_src

*** Lsp Bridge
Even faster completion?
#+begin_src emacs-lisp
;; (add-to-list 'load-path "~/src/lsp-bridge/")
;;
;; (use-package! lsp-bridge
;;   :config
;;   (setq lsp-bridge-enable-log nil)
;;   (global-lsp-bridge-mode))
;;
;; ;; disable completion after lsp-bridge starts up in a buffer
;; (setq company-global-modes nil)
;;
;; (defun personal-disable-completions-for-lsp-bridge ()
;;   (company-mode nil)
;;   (setq lsp-completion-enable nil))
;;
;; (add-hook! 'lsp-bridge-mode-hook #'personal-disable-completions-for-lsp-bridge)

#+end_src

** Centaur Tabs
*Disabled* because it is kind of intrusive with hooks, and it doesn't work when I run daemon anyway

Turn off tabs when the frame has a lot of splits in it (change function =personal-tab-window-limit=)
#+begin_src emacs-lisp
(defun personal-manage-tabs-with-splits (num-splits)
  "Hide tab bar when NUM-SPLITS or more (>=) windows are in the frame."
  (if (length> (window-list) (- num-splits 1))
      (walk-windows (lambda (w) (with-selected-window w (centaur-tabs-local-mode 1))))
    (walk-windows (lambda (w) (with-selected-window w (centaur-tabs-local-mode -1))))))

(defun personal-tab-window-limit ()
  "Function that is used in hook that calls `personal-manage-tabs-with-splits' with arg."
  (unless (frame-parent) ;; don't mess with tabs if its a child frame
    (personal-manage-tabs-with-splits 3)))

(if (and (display-graphic-p) (not (daemonp)))
    (after! centaur-tabs
      (add-hook! 'window-configuration-change-hook #'personal-tab-window-limit)))

;; Dont show tabs if in terminal mode (doesn't look good)
(after! centaur-tabs
  (unless (display-graphic-p)
    (centaur-tabs-mode -1)))

;; Don't use centaur tabs if started as a daemon
(after! centaur-tabs
  (when (daemonp)
    (centaur-tabs-mode -1)))
#+end_src

** Elfeed
Set the org file that configures feed
#+begin_src emacs-lisp
(setq rmh-elfeed-org-files '("~/.doom.d/elfeed.org"))
#+end_src

** vterm
Bind key to =vterm-other-window= which happens to open a terminal to the directory of the file it was
invoked in (useful)
#+begin_src emacs-lisp
(defun personal-vterm-here ()
  (interactive)
  "Open vterm in the directory of cursor.
Just calls `vterm-other-window', but also requires it to make it load beforehand."
  (require 'vterm)
  (vterm-other-window))

;; (map! :leader :mode 'global
;;       "oh" #'personal-vterm-here)
#+end_src
** COMMENT eshell
(disabled for now cuz eshell is slower than vterm which sucks)

a more integrated, emacsy shell
#+begin_src emacs-lisp
(after! eshell
  (defun corfu:send-shell ()
    "Send completion candidates when inside comint/shell."
    (cond
     ((and (derived-mode-p 'eshell-mode) (fboundp 'eshell-send-input))
      (eshell-send-input))
     ((and (derived-mode-p 'comint-mode)  (fboundp 'comint-send-input))
      (comint-send-input))))

  (defun eshell:setup-completion ()
    "Setup completion for EShell with ‚Äòcorfu‚Äô and ‚Äòcape‚Äô."
    (setq-local
     corfu-auto t
     corfu-quit-at-boundary t
     corfu-quit-no-match t
     corfu-auto-prefix 1
     completion-at-point-functions
     (list #'pcomplete-completions-at-point #'cape-file #'cape-history #'cape-dabbrev)
     )
    (advice-add #'corfu-insert :after #'corfu:send-shell))

  (add-hook! eshell-mode #'eshell:setup-completion))
#+end_src

load all alias
#+begin_src emacs-lisp
(defun eshell-load-zsh-aliases ()
  (interactive)
  "Read zsh aliases and add them to the list of eshell aliases."
  ;; Bash needs to be run - temporarily - interactively
  ;; in order to get the list of aliases.
  (with-temp-buffer
    (call-process "zsh" nil '(t nil) nil "-ci" "alias")
    (goto-char (point-min))
    (while (re-search-forward "\\(.+\\)='\\(.+\\)'$" nil t)
      (let
          ((name (match-string 1))
           (val (match-string 2)))
        (unless (string= name "z")
          (eshell/alias name val))))))

  ;; We only want Bash aliases to be loaded when Eshell loads its own aliases,
  ;; rather than every time `eshell-mode' is enabled.
  (add-hook 'eshell-alias-load-hook #'eshell-load-zsh-aliases)
  (add-hook! 'eshell-mode-hook #'eshell-load-zsh-aliases)
#+end_src

make eshell do what doom vterm does for project roots
#+begin_src emacs-lisp
(defun personal-eshell-toggle ()
  " Open up eshell as popup at project-root"
  (interactive)
  (let* ((project-root (or (doom-project-root) default-directory))
         (default-directory
          project-root))
    (setenv "PROOT" project-root)
    (+eshell/toggle project-root)))

(defun personal-eshell-here ()
  " Open up eshell as full frame at project-root"
  (interactive)
  (let* ((project-root (or (doom-project-root) default-directory))
         (default-directory
          project-root))
    (setenv "PROOT" project-root)
    (+eshell/here project-root)))
#+end_src

keybinds
#+begin_src emacs-lisp
(map! :leader :mode 'global
      "ot" #'personal-eshell-toggle
      "oT" #'personal-eshell-here
      ;; vterm when you need a true terminal
      "ov" #'+vterm/toggle
      "oV" #'+vterm/here
      )
#+end_src

** vlc
From [[https://ag91.github.io/blog/2021/01/25/vlc-via-emacs-how-to-open-a-youtube-link/][this page]]; setting up VLC so I can browse music in Emacs
#+begin_src emacs-lisp
(after! vlc
  (defun vlc-add-uri (uri &optional noaudio novideo)
    "Add URI to playlist and start playback.
NOAUDIO and NOVIDEO are optional options.
If NOAUDIO is non-nil, disable audio.
If NOVIDEO is non-nil, disable video.
When called interactively, with prefix arg, you can pick one."
    (interactive (cons (let ((uri (read-string "Add file or url: ")))
                         (if (s-starts-with-p "http" uri) uri
                           (concat "file://" (expand-file-name uri))))
                       (pcase current-prefix-arg
                         ('nil (list nil nil))
                         (_ (pcase (completing-read "Option: " '("noaudio" "novideo") nil t)
                              ("noaudio" (list t nil))
                              ("novideo" (list nil t)))))))
    (vlc-add uri noaudio novideo))

  (defun vlc-enqueue-uri (uri)
    "Add URI to playlist."
    (interactive (list (let ((uri (read-string "Add file or url: ")))
                         (if (s-starts-with-p "http" uri) uri
                           (concat "file://" (expand-file-name uri))))
                       ))
    (vlc-enqueue uri)))
#+end_src

Suggested from above link: add videos to queue if cursor is on it, and link in kill ring
#+begin_src emacs-lisp
(defun vlc-enqueue-uri-at-point ()
    "Add URI to playlist."
    (interactive)
    (let ((uri (thing-at-point 'url)))
      (when uri (vlc-enqueue uri))))

(defun vlc-uris-in-clipboard ()
    (--> (with-temp-buffer
           (clipboard-yank)
           (buffer-substring-no-properties (point-min) (point-max)))
         (s-split "\n" it)
         (--filter (s-starts-with-p "http" it) it)))

(defun vlc-enqueue-uris (uris)
    "Queue URIS to current VLC playlist."
    (interactive)
    (let ((uris (or uris (vlc-uris-in-clipboard))))
      (-each uris 'vlc-enqueue-uri)))

#+end_src

Keybinds for music playing (Use =<leader>1v= as the global keybind)
#+begin_src emacs-lisp
(map! :leader :mode 'global
      "1vs" #'vlc-start
      "1vr" #'vlc-play
      "1vR" #'vlc-pause
      "1vn" #'vlc-next
      "1vp" #'vlc-prev
      "1va" #'vlc-enqueue-uri-at-point
      "1ve" #'vlc-empty)
#+end_src

Function for opening up list
#+begin_src emacs-lisp
(defun personal-vlc-music-list ()
  (interactive)
  (let ((buf (find-file-noselect "~/Dropbox/agenda/music.org")))
    (floatbuf-make-floatbuf-with-buffer buf)))

(map! :leader :mode 'global
      "fbv" #'personal-vlc-music-list)
#+end_src

Strip music org file of song urls
#+begin_src emacs-lisp
(defun personal-queue-all-into-vlc ()
  "Use awk to put all files into vlc queue"
  (interactive)
  (require 'vlc)
  (let*
      ((music-file-loc (expand-file-name "~/Dropbox/agenda/music.org"))
       (awk-script-loc (expand-file-name "~/.doom.d/music-list-parse-all.awk"))
       (urls
        (shell-command-to-string (format "%s %s" awk-script-loc music-file-loc))))
    (mapc #'vlc-add-uri (split-string urls))))
#+end_src

** Blamer
Enable Blamer
#+begin_src emacs-lisp
(after! blamer
  (global-blamer-mode 1))

;; Make blamer load
(after! magit
       (require 'blamer))
#+end_src

** Demap
List of buffers and modes to not show the minimap in
#+begin_src emacs-lisp
(defvar personal-minimap-exclude-buffer-names '("*doom*")
  "List of buffer names that should not show the minibuffer if any are on the current frame")
(defvar personal-minimap-exclude-modes '(pdf-view-mode vterm-mode dired-mode image-mode magit-mode tetris-mode)
  "List of modes that should not show the minibuffer if any are on the current frame")
#+end_src

#+RESULTS:
: personal-minimap-exclude-modes

A function to start and stop the demap hook
#+begin_src emacs-lisp
(defun personal-start-demap-hook ()
  "Start the hook that shows a minimap if there's only 1 buffer"
  (interactive)
  (require 'demap)
  (require 'dash)
  (add-hook! 'window-configuration-change-hook #'personal-minimap-for-one-window)
  (setq personal-demap-hook-active t))

(defun personal-stop-demap-hook ()
  "Stop the hook that shows a minimap if there's only 1 buffer"
  (interactive)
  (remove-hook! 'window-configuration-change-hook #'personal-minimap-for-one-window)
  (setq personal-demap-hook-active nil))

(defun personal-toggle-demap-hook ()
  "Toggle the hook that shows a minimap if there's only 1 buffer"
  (interactive)
  (if personal-demap-hook-active
      (personal-stop-demap-hook)
    (personal-start-demap-hook)))
#+end_src

Turn on the minimap when there is only 1 active window
#+begin_src emacs-lisp
(defun personal-should-show-minimap ()
  "`nil' if the window doesn't contain something that shouldn't have a minimap."
  (cl-flet ((has-excluded-name (w)
         ;; don't show if it has an excluded name
         (member (buffer-name (window-buffer w)) personal-minimap-exclude-buffer-names))
        (has-excluded-mode (w)
         ;; don't show if one of these modes is included
         (member (with-current-buffer (window-buffer w) major-mode) personal-minimap-exclude-modes)))
    (and
     (display-graphic-p)
     (not (-any? (lambda (w) (or (has-excluded-name w) (has-excluded-mode w))) (window-list nil 1 nil))))))

(defun personal-manage-minimap-with-splits (num-splits)
  "hide/show demap minimap when num-splits or more (>=) windows are in the frame."
  (let ((window-list-without-minimap
         (-filter
          (lambda (n) (not (string= n demap-minimap-default-name)))
          (mapcar (lambda (w) (buffer-name (window-buffer w))) (window-list nil 1 nil)))))
    (if (and (personal-should-show-minimap) (not (length> window-list-without-minimap (- num-splits 1))))
        (progn (demap-open))
      (progn (demap-close)))))

(defun personal-minimap-for-one-window ()
  "function that is used in hook that calls `personal-manage-minimap-with-splits'."
  (unless (frame-parent) ;; don't mess with minimap in child frames
    (personal-manage-minimap-with-splits 2)))
#+end_src

Keybinding for toggling demap minimap
#+begin_src emacs-lisp
;; (map! :after demap :leader :mode 'global
;;   "tm" #'demap-toggle
;;   "tM" #'personal-toggle-demap-hook)
#+end_src

Autostart the hook
#+begin_src emacs-lisp
;; (personal-start-demap-hook)
#+end_src
** Leetcode
Randomize the language I solve questions in
#+begin_src emacs-lisp
;; (after! leetcode
;;   (setq personal-leetcode-random-languages
;;         '("c"
;;           "c++"
;;           "java"
;;           "rust"
;;           "python3"
;;           "c#"
;;           "typescript"
;;           "swift"
;;           "go"
;;           "scala"
;;           "elixir"
;;           "scala"))
;;
;;   (defun personal-choose-random-leetcode-language ()
;;     (interactive)
;;     (let ((language (nth (random (length personal-leetcode-random-languages)) personal-leetcode-random-languages)))
;;       (setq leetcode-prefer-language language)))
;;
;;   (defun personal-set-leetcode-language ()
;;     (interactive)
;;     (setq leetcode-prefer-language (read-from-minibuffer "language? ")))
;;
;;   (defadvice! personal-leetcode-randomize-language ()
;;     :after #'leetcode
;;     (personal-choose-random-leetcode-language)))

;;(after! leetcode
;;  (defun personal-choose-random-leetcode-language ()
;;    (interactive)
;;    (let ((language (nth (random (length personal-leetcode-random-languages)) personal-leetcode-random-languages)))
;;      (setq leetcode-prefer-language "cpp")))
;;
;;  (defun personal-set-leetcode-language ()
;;    (interactive)
;;    (setq leetcode-prefer-language (read-from-minibuffer "language? ")))
;;
;;  (defadvice! personal-leetcode-randomize-language ()
;;    :after #'leetcode
;;    (personal-choose-random-leetcode-language)))

#+end_src

** GCMH
#+begin_src emacs-lisp
(gcmh-mode 1)
(setq gcmh-verbose t)
#+end_src

#+RESULTS:
: t

** VLF
Load VLF mode when not much is happening
#+begin_src emacs-lisp
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src
** Olivetti
Code in the middle
#+begin_src emacs-lisp
(add-hook! prog-mode
           (require 'auto-olivetti))

(after! auto-olivetti
  (setq auto-olivetti-enabled-modes '(text-mode org-mode prog-mode))
  (auto-olivetti-mode t))
#+end_src

** Proced Mode
Set proced to auto update and be like top
#+begin_src emacs-lisp
(setq proced-auto-update-flag t)
(setq proced-auto-update-interval 2)
#+end_src

** Undo Tree
Show timestamps
#+begin_src emacs-lisp
(after! undo-tree
  (setq undo-tree-visualizer-timestamps t))
#+end_src
** Rainbow Delimiters Mode
#+begin_src emacs-lisp
(add-hook! prog-mode #'rainbow-delimiters-mode)
#+end_src
* Programming
** C Family
Setup LSP-mode with clangd based on [[file:~/.emacs.d/modules/lang/cc/README.org::*Eglot with clangd][this]]
#+BEGIN_SRC elisp
;; (set-eglot-client! 'cc-mode '("clangd" "-j=3" "--clang-tidy"))

(setq lsp-clients-clangd-args '("-j=3"
                                "--background-index"
                                "--clang-tidy"
                                "--completion-style=detailed"
                                "--pch-storage=memory"
                                "--header-insertion=never"))
(after! lsp-clangd (set-lsp-priority! 'clangd 2))
#+END_SRC

Map <Space>ff to =ff-find-other-file= for Cpp
#+BEGIN_SRC emacs-lisp
(map! :mode 'cpp-mode :leader
      " ff" #'ff-find-other-file)
#+END_SRC

Org source blocks should use up to date cpp
#+begin_src emacs-lisp
(defvar org-babel-default-header-args:cpp '((:flags . "-std=c++20")))
#+end_src

(default) Formatter options for the C family
#+begin_src emacs-lisp
(set-formatter! 'clang-format
  '("clang-format"
    "-style={BasedOnStyle: llvm, IndentWidth: 2, SortIncludes: true, ColumnLimit: 100}"
    ("-assume-filename=%S" (or buffer-file-name mode-result "")))
  :modes '(cpp-mode c-mode))
#+end_src

*Note to self*
Can set the =C++= version of projects using directory local variables for clang flychecker
#+begin_quote
Open the root directory of your project in Dired with C-x d, and then type M-x add-dir-local-variable RET c++-mode RET flycheck-gcc-language-standard RET "c++11". This will create a .dir-locals.el file in the root directory of your project. Emacs reads this file whenever you visit a file from this directory or any subdirectory, and sets variables according to the rules in this file. Specifically, Emacs will now set the language standard for Flycheck syntax checking to C++ 11 for all C++ files in your project.
#+end_quote

*Another Note to self*
I have abbreviations to make coding in C++ less work in [[~/.doom.d/abbrev.el]]

** OR Tools
Useful stuff for working with linear programs and the like.

Hook AMPL relate files to [[https://github.com/dpo/ampl-mode][ampl-mode]].
#+BEGIN_SRC emacs-lisp
(setq auto-mode-alist
      (cons '("\\.mod$" . ampl-mode) auto-mode-alist))
(setq auto-mode-alist
      (cons '("\\.dat$" . ampl-mode) auto-mode-alist))
(setq auto-mode-alist
      (cons '("\\.ampl$" . ampl-mode) auto-mode-alist))
(setq auto-mode-alist
      (cons '("\\.ampl$" . ampl-mode) auto-mode-alist))
(setq interpreter-mode-alist
      (cons '("ampl" . ampl-mode)
            interpreter-mode-alist))
(autoload 'ampl-mode "ampl-mode" "Ampl editing mode." t)
#+END_SRC

Recommend previously used words in AMPL mode
#+BEGIN_SRC emacs-lisp
(add-hook! ampl-mode
  (set-company-backend! 'ampl-mode 'company-dabbrev))
#+END_SRC
** Rust
Configs for coding in the rust programming language.

Set ~RUST_SRC_PATH~ for racer:
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (let* ((rust-lib-path "/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library")
         (rust-full-path (concat (substitute-in-file-name "$HOME") rust-lib-path)))
    (setq racer-rust-src-path rust-full-path)))
#+END_SRC

Setup completion in rust
#+BEGIN_SRC emacs-lisp
(add-hook! rust-mode
  (set-company-backend! 'rust-mode '(company-capf company-dabbrev company-yasnippet)))
#+END_SRC

** Swift
Configurations for the swift programming language.

Setup =lsp-sourcekit= to work swift files...
#+BEGIN_SRC emacs-lisp
;; (after! lsp-sourcekit
;;   (setenv "SOURCEKIT_TOOLCHAIN_PATH" "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain")
;;   (setq lsp-sourcekit-executable (string-trim (shell-command-to-string "xcrun --find sourcekit-lsp"))))
#+END_SRC

Recommend previously used words in swift files to compensate for spotty sourcekit support:
#+BEGIN_SRC emacs-lisp
(add-hook! swift-mode
  (set-company-backend! 'swift-mode '(company-sourcekit company-dabbrev company-capf company-yasnippet)))
#+END_SRC

Add =swiftlint= as a linter in swift files
#+BEGIN_SRC elisp
(with-eval-after-load 'flycheck
  (flycheck-swiftlint-setup))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq flycheck-python-flake8-executable "~/Library/Python/3.8/bin/flake8"))
#+END_SRC

Which python is used:
#+BEGIN_SRC emacs-lisp
(when IS-MAC
  (setq python-shell-exec-path '("/usr/local/bin/python3"))
  (setq python-shell-remote-exec-path '("/usr/local/bin/python3")))
#+END_SRC

Map the commands for sending lines to REPL to something less painful
#+BEGIN_SRC emacs-lisp
(map! :mode 'python-mode :leader
      "ml" #'python-shell-send-statement
      "mr" #'python-shell-send-region
      "mf" #'python-shell-send-defun)
#+END_SRC

Stop the warning about native read line
#+begin_src emacs-lisp
(with-eval-after-load 'python
  (defun python-shell-completion-native-try ()
    "Return non-nil if can trigger native completion."
    (let ((python-shell-completion-native-enable t)
          (python-shell-completion-native-output-timeout
           python-shell-completion-native-try-output-timeout))
      (python-shell-completion-native-get-completions
       (get-buffer-process (current-buffer))
       nil "_"))))

(setq python-shell-completion-native-enable nil)
#+end_src

Set tab size and stuff
#+begin_src emacs-lisp
(add-hook 'python-mode-hook
      (lambda ()
        (setq indent-tabs-mode nil)
        (setq tab-width 4)
        (setq python-indent-offset 4)))
#+end_src

Set abbrev mode
#+begin_src emacs-lisp
(defun personal-turn-on-abbrev-mode ()
  """Turn on abbrev mode. """
  (abbrev-mode))

(add-hook! python-mode
  #'personal-turn-on-abbrev-mode)

(add-hook! c++-ts-mode
  #'personal-turn-on-abbrev-mode)
#+end_src

* Functions for me
** Browsing the World Wide Web
Look it up online
#+begin_src emacs-lisp
(defun personal-lookup-online ()
  " Search something online."
  (interactive)
  (let ((question (completing-read "‚ùì Look up online: " nil)))
    (+lookup/online question "DuckDuckGo")))

(defun personal-lookup-online-eww ()
  " Search something with EWW."
  (interactive)
  (let* ((question (completing-read "‚ùì Look up with EWW: " nil))
         (question-hexified (url-hexify-string question))
         (search-url (format "https://html.duckduckgo.com/html/?q=%s" question-hexified)))
    (eww-browse-url search-url)))

(defun personal-ask-chatgpt ()
  " Ask a question using ChatGPT."
  (interactive)
  (let* ((question (completing-read "ü§ñ Look up with ChatGPT: " nil))
         (question-hexified (url-hexify-string question))
         (search-url (format "https://chat.openai.com/?q=%s" question-hexified)))
    (browse-url search-url)))
#+end_src

Look up a cpp term using cppman
#+begin_src emacs-lisp
(defun personal-lookup-cppman ()
  " Search a term on cppref using cppman."
  (interactive)
  (let* ((term (completing-read "‚ùì C++ : " nil))
         (command (concat "cppman " term)))
    (shell-command command)))
#+end_src

Keybinds
#+begin_src emacs-lisp
(map! :leader :mode 'global
      "zz" #'personal-lookup-online-eww
      "zZ" #'personal-lookup-online
      "zc" #'personal-ask-chatgpt)
#+end_src

Mode specific keybinds
#+begin_src emacs-lisp
(map! :leader :map c++-mode-map
      "zd" #'personal-lookup-cppman)
#+end_src

* Misc/Random
** Fun Stuff
 Fun Emacs things

 Zone mode screen saver after a good amount of idle time
 #+BEGIN_SRC emacs-lisp
 (require 'zone)
 (zone-when-idle 600) ;; 10 minutes
 #+END_SRC

Disable all non productive stuff (for lectures or presentations)
#+BEGIN_SRC emacs-lisp
(defun personal-look-professional ()
  "Disable all idle animations and related."
  (interactive)
  (huecycle-stop-idle)
  (huecycle-reset-all-faces-on-all-buffers)
  (zone-leave-me-alone))
#+END_SRC

Add rainbow to zone programs
#+BEGIN_SRC elisp
(setq zone-programs (vconcat [zone-rainbow] zone-programs))
#+END_SRC

Enable sound support
#+BEGIN_SRC elisp
(unless (and (fboundp 'play-sound-internal)
             (subrp (symbol-function 'play-sound-internal)))
  (require 'play-sound))
#+END_SRC

Set some faces to change color when idle
#+BEGIN_SRC elisp
(require 'huecycle)

(setq personal--hl-line-bg-light-arg (ewal-load-color 'white -19.5))
(setq personal--hl-line-bg-dark-arg (ewal-load-color 'black -17.5))

;; Less packages, to do huecycle at startup
(after! (huecycle doom-modeline hl-line ewal)
  (huecycle-set-faces
   ;; rainbow stuff
   ((foreground . (doom-modeline-evil-normal-state
                   doom-modeline-evil-insert-state
                   doom-modeline-buffer-major-mode
                   line-number-current-line
                   doom-modeline-panel
                   doom-modeline-info
                   ))
    :random-color-hue-range (0.0 1.0)
    :random-color-saturation-range (0.8 1.0)
    :random-color-luminance-range (0.5 0.8)
    :speed 0.5)

   ;; highlight rainbow
   ((foreground . region)
    :random-color-hue-range (0.0 1.0)
    :random-color-saturation-range (0.9 1.0)
    :random-color-luminance-range (0.5 0.8))

   ;; Non Rainbow stuff
   ((background . hl-line)
    :color-list (personal--hl-line-bg-light-arg personal--hl-line-bg-dark-arg personal--hl-line-bg-dark-arg)
    :next-color-func huecycle-get-next-list-color
    :speed 1.5
    :persist t))
  (huecycle-when-idle 1.0))

;;  (setq huecycle-buffers-to-huecycle-in
;;        (list
;;         #'current-buffer
;;         (lambda ()
;;           (company-box--get-buffer))))
;;  (huecycle-when-idle 1.0))

;; More packages, all faces to huecycle with
(after! (huecycle doom-modeline hl-line ewal lsp-mode)
  (huecycle-set-faces
   ;; rainbow stuff
   ((foreground . (doom-modeline-evil-normal-state
                   doom-modeline-evil-insert-state
                   doom-modeline-buffer-major-mode
                   line-number-current-line
                   doom-modeline-lsp-success
                   doom-modeline-panel
                   doom-modeline-info
                   lsp-face-highlight-write
                   lsp-face-highlight-read
                   ))
    :random-color-hue-range (0.0 1.0)
    :random-color-saturation-range (0.8 1.0)
    :random-color-luminance-range (0.5 0.8)
    :speed 0.5)

   ;; highlight rainbow
   ((foreground . region)
    :random-color-hue-range (0.0 1.0)
    :random-color-saturation-range (0.9 1.0)
    :random-color-luminance-range (0.5 0.8))

   ;; Non Rainbow stuff; hl-line glow
   ((background . hl-line)
    :color-list (personal--hl-line-bg-light-arg personal--hl-line-bg-dark-arg personal--hl-line-bg-dark-arg)
    :next-color-func huecycle-get-next-list-color
    :speed 1.5
    :persist t)))

  ;; Add the demap minimap
  ;; (setq huecycle-buffers-to-huecycle-in
  ;;       (list
  ;;        #'current-buffer
  ;;        (lambda ()
  ;;          (company-box--get-buffer)))))

#+END_SRC

#+RESULTS:
| #s(huecycle--interp-datum ((foreground doom-modeline-evil-normal-state doom-modeline-evil-insert-state doom-modeline-buffer-major-mode line-number-current-line doom-modeline-lsp-success doom-modeline-panel doom-modeline-info lsp-face-highlight-write lsp-face-highlight-read)) nil nil nil 0.0 huecycle-interpolate-linear huecycle-get-random-hsl-color nil (0.0 1.0) (0.8 1.0) (0.5 0.8) 0 nil 0.5 nil) | #s(huecycle--interp-datum ((foreground region)) nil nil nil 0.0 huecycle-interpolate-linear huecycle-get-random-hsl-color nil (0.0 1.0) (0.9 1.0) (0.5 0.8) 0 nil 1.0 nil) | #s(huecycle--interp-datum ((background hl-line)) nil nil nil 0.0 huecycle-interpolate-linear huecycle-get-next-list-color (#s(huecycle--color 0.08333333333333363 0.024390243902439025 0.16078431372549018) #s(huecycle--color 0.07407407407407411 0.045685279187817236 0.3862745098039216) #s(huecycle--color 0.07407407407407411 0.045685279187817236 0.3862745098039216)) (0.0 1.0) (0.5 1.0) (0.2 0.3) 0 nil 1.5 t) |

** Scratch Space
Space for random elisp
#+BEGIN_SRC elisp
;; (require 'random-theme)
(if IS-MAC
    (load "~/.doom.d/local_packages/random-theme/random-theme.el"))
;; mad hacky but too lazy to look into this

(if (and (display-graphic-p) IS-MAC)
    (defadvice! personal-random-theme-on-reload-last ()
      :after #'doom/quickload-session
      (random-theme-set-theme)))

(defun personal-refresh-ewal-emacs-theme ()
  "Refreshes the ewal-doom-one theme based on current background"
  (interactive)
  (load-theme 'ewal-doom-one)
  (setq ewal-doom-vibrant-brighter-comments t)
  (setq ewal-doom-vibrant-comment-bg nil)
  (personal-make-fixed-pitch-shrink)
  (personal-make-ewal-comment-brighter)
  (personal-fixup-fonts-org-mode))
#+END_SRC

* Orgmode footer args
#+localWords: MacOS, PDFs, ampl, Config, Configs, sourcekit, flycheck
